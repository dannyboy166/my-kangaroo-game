<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kangaroo Hop</title>
    <!-- Modern Google Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            font-family: 'Poppins', sans-serif;
        }
        #gameContainer {
            position: relative;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5), 0 0 40px rgba(79, 172, 254, 0.15);
        }
        canvas {
            display: block;
            border-radius: 16px;
            cursor: pointer;
            /* Force GPU acceleration */
            transform: translateZ(0);
            will-change: transform;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="game" width="800" height="600"></canvas>
        <div id="loading">Loading...</div>
    </div>

    <script>
        // ============================================
        // KANGAROO HOP - Raw Canvas Edition
        // No frameworks, just pure JavaScript
        // ============================================

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d', {
            alpha: false,        // Disable transparency for performance
            desynchronized: true // Reduce latency
        });
        const loadingEl = document.getElementById('loading');

        // === AUDIO ===
        const sounds = {
            jump: new Audio('assets/audio/sfx/jump.mp3'),
            doubleJump: new Audio('assets/audio/sfx/double_jump.mp3'),
            coin: new Audio('assets/audio/sfx/coin_collect.mp3'),
            collision: new Audio('assets/audio/sfx/collision.mp3'),
            gameOver: new Audio('assets/audio/sfx/game_over.mp3')
        };

        // Set volumes
        sounds.jump.volume = 0.5;
        sounds.doubleJump.volume = 0.5;
        sounds.coin.volume = 0.7;
        sounds.collision.volume = 0.6;
        sounds.gameOver.volume = 0.8;

        function playSound(name) {
            const sound = sounds[name];
            if (sound) {
                sound.currentTime = 0; // Rewind to start
                sound.play().catch(() => {}); // Ignore autoplay errors
            }
        }

        // Helper: Draw rounded rectangle
        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        // === CONSTANTS ===
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const GROUND_Y = 500;
        const GRAVITY = 0.8;
        const JUMP_FORCE = -20;
        const INITIAL_SPEED = 6;
        const MAX_SPEED = 14;
        const SPEED_INCREMENT = 0.002;

        // === ASSETS ===
        const assets = {};
        const assetList = [
            { name: 'kangaroo', src: 'assets/images/kangaroos.png' },
            { name: 'ground', src: 'assets/images/parallax/_01_ground.png' },
            { name: 'background', src: 'assets/images/parallax/_11_background.png' },
            { name: 'clouds', src: 'assets/images/parallax/_08_clouds.png' },
            { name: 'hills', src: 'assets/images/parallax/_06_hill2.png' },
            { name: 'rock', src: 'assets/images/rock.png' },
            { name: 'cactus', src: 'assets/images/cactus.png' },
            { name: 'snakeLog', src: 'assets/images/snake_log.png' },
            { name: 'emu', src: 'assets/images/emu_sheet.png' },
            { name: 'magpie', src: 'assets/images/magpie_sheet.png' },
            { name: 'coin', src: 'assets/images/coin/coin-64x64.png' }
        ];

        function loadAssets(callback) {
            let loaded = 0;
            const total = assetList.length;

            assetList.forEach(asset => {
                const img = new Image();
                img.onload = () => {
                    assets[asset.name] = img;
                    loaded++;
                    console.log(`âœ“ Loaded: ${asset.name} (${img.width}x${img.height})`);
                    loadingEl.textContent = `Loading... ${Math.floor(loaded / total * 100)}%`;
                    if (loaded === total) {
                        loadingEl.style.display = 'none';
                        console.log('All assets loaded:', Object.keys(assets));
                        callback();
                    }
                };
                img.onerror = () => {
                    console.error(`âœ— Failed to load: ${asset.name} from ${asset.src}`);
                    loaded++;
                    if (loaded === total) {
                        loadingEl.style.display = 'none';
                        callback();
                    }
                };
                img.src = asset.src;
            });
        }

        // FPS tracking
        let fps = 0;
        let frameCount = 0;
        let lastFpsUpdate = Date.now();

        // Delta time for smooth movement
        let lastFrameTime = performance.now();
        let deltaTime = 0;

        // === DEBUG MODE ===
        const DEBUG = false; // Set to false to hide debug info

        // === PARTICLES ===
        let particles = [];

        function spawnDustParticles(x, y) {
            // Spawn 8-12 dust particles
            const count = 8 + Math.floor(Math.random() * 5);
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 40,
                    y: y,
                    vx: (Math.random() - 0.5) * 150,
                    vy: -Math.random() * 80 - 20,
                    size: 4 + Math.random() * 8,
                    life: 0.4 + Math.random() * 0.3,
                    maxLife: 0.4 + Math.random() * 0.3,
                    color: Math.random() > 0.5 ? '#C4A574' : '#A68B5B',
                    type: 'dust'
                });
            }
        }

        function spawnCoinSparkles(x, y) {
            // Spawn golden sparkles
            const count = 12 + Math.floor(Math.random() * 6);
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
                const speed = 100 + Math.random() * 150;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 3 + Math.random() * 5,
                    life: 0.3 + Math.random() * 0.3,
                    maxLife: 0.3 + Math.random() * 0.3,
                    color: Math.random() > 0.5 ? '#FFD700' : '#FFF176',
                    type: 'sparkle'
                });
            }
        }

        // Screen shake
        let screenShake = { intensity: 0, duration: 0 };

        function triggerScreenShake(intensity, duration) {
            screenShake.intensity = intensity;
            screenShake.duration = duration;
        }

        function updateScreenShake(dt) {
            if (screenShake.duration > 0) {
                screenShake.duration -= dt;
            } else {
                screenShake.intensity = 0;
            }
        }

        function getShakeOffset() {
            if (screenShake.intensity > 0) {
                return {
                    x: (Math.random() - 0.5) * screenShake.intensity * 2,
                    y: (Math.random() - 0.5) * screenShake.intensity * 2
                };
            }
            return { x: 0, y: 0 };
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];

                // Move
                p.x += p.vx * dt;
                p.y += p.vy * dt;

                // Gravity only for dust, not sparkles
                if (p.type === 'dust') {
                    p.vy += 200 * dt;
                } else if (p.type === 'sparkle') {
                    // Sparkles slow down
                    p.vx *= 0.95;
                    p.vy *= 0.95;
                }

                // Fade out
                p.life -= dt;

                // Remove dead particles
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                const alpha = p.life / p.maxLife;

                if (p.type === 'sparkle') {
                    // Sparkles are brighter and have glow effect
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(Math.round(p.x), Math.round(p.y), p.size * alpha * 1.5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(Math.round(p.x), Math.round(p.y), p.size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Dust particles
                    ctx.globalAlpha = alpha * 0.7;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(Math.round(p.x), Math.round(p.y), p.size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            ctx.globalAlpha = 1;
        }

        // === GAME STATE ===
        let gameSpeed = INITIAL_SPEED;
        let score = 0;
        let highScore = parseInt(localStorage.getItem('kangaroo_raw_high')) || 0;
        let coinsCollected = 0;
        let totalCoins = parseInt(localStorage.getItem('kangaroo_raw_coins')) || 0;
        let gameOver = false;
        let showGameOverUI = false;
        let gameOverTimer = 0;
        let gameStarted = false;
        let groundOffset = 0;
        let cloudsOffset = 0;
        let hillsOffset = 0;

        // === KANGAROO ===
        const DOUBLE_JUMP_FORCE = -17; // Slightly weaker than first jump

        const kangaroo = {
            x: 100,
            y: GROUND_Y,
            width: 110,
            height: 140,
            velocityY: 0,
            onGround: true,
            wasOnGround: true, // Track previous frame
            canDoubleJump: false, // Can we do a second jump?
            frame: 0,
            frameTimer: 0,
            frameDelay: 4, // Frames between animation updates

            // Squash & stretch
            scaleX: 1,
            scaleY: 1,
            squashTime: 0,

            // Death animation
            isDead: false,
            deathRotation: 0,
            deathVelocityY: 0,

            // Sprite sheet: 6 columns x 2 rows = 12 frames, each 128x128
            spriteWidth: 128,
            spriteHeight: 128,
            totalFrames: 12,

            update(dt) {
                // Handle death animation separately
                if (this.isDead) {
                    this.updateDeath(dt);
                    return;
                }

                this.wasOnGround = this.onGround;

                // Gravity (using delta time)
                const gravityPerSecond = GRAVITY * 60; // Convert to per-second
                this.velocityY += gravityPerSecond * dt;
                this.y += this.velocityY * dt * 60;

                // Ground collision
                if (this.y >= GROUND_Y) {
                    this.y = GROUND_Y;
                    this.velocityY = 0;
                    this.onGround = true;
                    this.canDoubleJump = false; // Reset on landing

                    // Trigger squash on landing
                    if (!this.wasOnGround) {
                        this.squashTime = 0.15; // Duration of squash
                        this.scaleX = 1.3;  // Wider
                        this.scaleY = 0.7;  // Shorter
                        // Spawn dust particles!
                        spawnDustParticles(this.x, GROUND_Y);
                    }
                }

                // Animate squash back to normal
                if (this.squashTime > 0) {
                    this.squashTime -= dt;
                    // Lerp back to normal
                    this.scaleX += (1 - this.scaleX) * 10 * dt;
                    this.scaleY += (1 - this.scaleY) * 10 * dt;
                } else {
                    this.scaleX = 1;
                    this.scaleY = 1;
                }

                // Animation (time-based)
                this.frameTimer += dt;
                if (this.frameTimer >= 0.05) { // ~20fps animation
                    this.frameTimer = 0;
                    if (this.onGround) {
                        this.frame = (this.frame + 1) % this.totalFrames;
                    }
                }
            },

            die() {
                this.isDead = true;
                this.deathVelocityY = -10; // Pop up
                this.deathRotation = 0;
            },

            updateDeath(dt) {
                if (!this.isDead) return;

                // Fall and spin
                this.deathVelocityY += 30 * dt; // Gravity
                this.y += this.deathVelocityY;
                this.deathRotation += 8 * dt; // Spin

                // Fade out or fall off screen
            },

            jump() {
                if (this.isDead) return; // Can't jump when dead
                if (this.onGround) {
                    // First jump
                    this.velocityY = JUMP_FORCE;
                    this.onGround = false;
                    this.canDoubleJump = true; // Enable double jump
                    this.frame = 3; // Jump frame
                    playSound('jump');
                    // Stretch effect (taller, narrower)
                    this.scaleX = 0.8;
                    this.scaleY = 1.2;
                    this.squashTime = 0.1;
                } else if (this.canDoubleJump) {
                    // Double jump!
                    this.velocityY = DOUBLE_JUMP_FORCE;
                    this.canDoubleJump = false; // Used up
                    this.frame = 3; // Reset jump frame
                    playSound('doubleJump');
                    // Stretch effect
                    this.scaleX = 0.8;
                    this.scaleY = 1.2;
                    this.squashTime = 0.1;
                }
            },

            draw() {
                // Calculate scaled dimensions
                const scaledWidth = this.width * this.scaleX;
                const scaledHeight = this.height * this.scaleY;

                // Round positions to avoid sub-pixel jitter
                const drawX = Math.round(this.x);
                const drawY = Math.round(this.y);

                ctx.save();

                // Apply death rotation if dead
                if (this.isDead) {
                    ctx.translate(drawX, drawY - scaledHeight / 2);
                    ctx.rotate(this.deathRotation);
                    ctx.translate(-drawX, -(drawY - scaledHeight / 2));
                }

                if (USE_SIMPLE_BOXES) {
                    // Simple brown box for kangaroo
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(drawX - scaledWidth / 2, drawY - scaledHeight, scaledWidth, scaledHeight);
                    ctx.fillStyle = '#FFF';
                    ctx.font = 'bold 14px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('ROO', drawX, drawY - scaledHeight / 2);
                    ctx.textAlign = 'left';
                } else if (assets.kangaroo) {
                    const col = this.frame % 6;
                    const row = Math.floor(this.frame / 6);
                    const srcX = col * this.spriteWidth;
                    const srcY = row * this.spriteHeight;

                    ctx.drawImage(
                        assets.kangaroo,
                        srcX, srcY, this.spriteWidth, this.spriteHeight,
                        drawX - scaledWidth / 2, drawY - scaledHeight,
                        scaledWidth, scaledHeight
                    );
                }

                ctx.restore();

                // Debug: draw hitbox
                if (DEBUG) {
                    const bounds = this.getBounds();
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(
                        Math.round(bounds.x),
                        Math.round(bounds.y),
                        bounds.width,
                        bounds.height
                    );

                    // Show frame number
                    ctx.fillStyle = '#00FF00';
                    ctx.font = '12px monospace';
                    ctx.fillText(`F:${this.frame}`, Math.round(this.x) - 15, drawY - 5);
                }
            },

            getBounds() {
                // Smaller hitbox for fair gameplay
                const padding = 15;
                const reducedHeight = (this.height - padding * 2) * 0.5; // 50% shorter
                return {
                    x: this.x - this.width / 2 + padding,
                    y: this.y - reducedHeight - padding, // Anchored to bottom
                    width: this.width - padding * 2,
                    height: reducedHeight
                };
            }
        };

        // === OBSTACLES ===
        let obstacles = [];
        let lastObstacleTime = 0;
        let obstacleInterval = 1500;

        const obstacleTypes = [
            { name: 'rock', asset: 'rock', width: 85, height: 70, animated: false },
            { name: 'cactus', asset: 'cactus', width: 70, height: 100, animated: false },
            { name: 'snakeLog', asset: 'snakeLog', width: 110, height: 70, animated: false },
            { name: 'emu', asset: 'emu', width: 110, height: 125, animated: true, frames: 4, frameWidth: 128, frameHeight: 128 },
            { name: 'magpie', asset: 'magpie', width: 80, height: 70, animated: true, frames: 4, frameWidth: 128, frameHeight: 128, flying: true }
        ];

        function spawnObstacle() {
            // Pick random type (magpie less common)
            let typeIndex;
            if (Math.random() < 0.15 && score > 500) {
                typeIndex = 4; // Magpie
            } else if (Math.random() < 0.2 && score > 300) {
                typeIndex = 3; // Emu
            } else {
                typeIndex = Math.floor(Math.random() * 3); // Rock, cactus, or snake log
            }

            const type = obstacleTypes[typeIndex];
            const obstacle = {
                x: CANVAS_WIDTH + 50,
                y: type.flying ? GROUND_Y - 80 - Math.random() * 60 : GROUND_Y,
                width: type.width,
                height: type.height,
                type: type,
                frame: 0,
                frameTimer: 0,
                // Magpie swoop
                swooping: false,
                swoopTarget: GROUND_Y - 30
            };

            obstacles.push(obstacle);

            // Maybe spawn a coin nearby
            if (Math.random() < 0.6) {
                spawnCoin(obstacle.x + 50 + Math.random() * 100);
            }
        }

        function updateObstacles(dt, pixelsPerSecond) {
            const now = Date.now();

            // Spawn new obstacles
            if (now - lastObstacleTime > obstacleInterval) {
                spawnObstacle();
                lastObstacleTime = now;
                // Vary interval
                obstacleInterval = 1200 + Math.random() * 800 - (score * 0.5);
                obstacleInterval = Math.max(600, obstacleInterval);
            }

            // Update existing obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];

                // Move using delta time (smooth!)
                obs.x -= pixelsPerSecond * dt;

                // Animate (time-based)
                if (obs.type.animated && obs.type.frames > 0) {
                    obs.frameTimer += dt;
                    if (obs.frameTimer >= 0.1) { // 10fps animation
                        obs.frameTimer = 0;
                        obs.frame = (obs.frame + 1) % obs.type.frames;
                    }
                }

                // Magpie swoop AI
                if (obs.type.flying && !obs.swooping && obs.x < kangaroo.x + 200 && score > 500) {
                    if (Math.random() < 0.02) {
                        obs.swooping = true;
                    }
                }
                if (obs.swooping) {
                    if (obs.y < obs.swoopTarget) {
                        obs.y += 180 * dt; // 180 pixels per second swoop
                    }
                }

                // Remove off-screen
                if (obs.x < -100) {
                    obstacles.splice(i, 1);
                    score += 10;
                }
            }
        }

        // Toggle to use simple boxes instead of images
        const USE_SIMPLE_BOXES = false;

        const obstacleColors = {
            rock: '#666666',
            cactus: '#228B22',
            snakeLog: '#8B4513',
            emu: '#4169E1',
            magpie: '#333333'
        };

        function drawObstacles() {
            obstacles.forEach(obs => {
                if (USE_SIMPLE_BOXES) {
                    // Simple colored box
                    ctx.fillStyle = obstacleColors[obs.type.name] || '#FF0000';
                    ctx.fillRect(
                        Math.round(obs.x - obs.width / 2),
                        Math.round(obs.y - obs.height),
                        obs.width,
                        obs.height
                    );

                    // Label
                    ctx.fillStyle = '#FFF';
                    ctx.font = 'bold 12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(obs.type.name, Math.round(obs.x), Math.round(obs.y - obs.height / 2));
                    ctx.textAlign = 'left';
                } else {
                    // Original image-based rendering
                    const asset = assets[obs.type.asset];
                    if (!asset) return;

                    try {
                        if (obs.type.animated) {
                            const safeFrame = Math.max(0, Math.min(obs.frame, obs.type.frames - 1));
                            const srcX = safeFrame * obs.type.frameWidth;
                            ctx.drawImage(
                                asset,
                                srcX, 0, obs.type.frameWidth, obs.type.frameHeight,
                                obs.x - obs.width / 2, obs.y - obs.height,
                                obs.width, obs.height
                            );
                        } else {
                            ctx.drawImage(
                                asset,
                                obs.x - obs.width / 2, obs.y - obs.height,
                                obs.width, obs.height
                            );
                        }
                    } catch (e) {
                        console.error('Draw error:', obs.type.name, e);
                    }
                }

                // Debug: draw hitbox
                if (DEBUG) {
                    const hitbox = {
                        x: obs.x - obs.width / 2 + 10,
                        y: obs.y - obs.height + 10,
                        width: obs.width - 20,
                        height: obs.height - 20
                    };
                    ctx.strokeStyle = '#FF0000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(
                        Math.round(hitbox.x),
                        Math.round(hitbox.y),
                        hitbox.width,
                        hitbox.height
                    );
                }
            });
        }

        // === COINS ===
        let coins = [];

        function spawnCoin(x) {
            coins.push({
                x: x || CANVAS_WIDTH + Math.random() * 200,
                y: GROUND_Y - 50 - Math.random() * 80,
                size: 40,
                frame: 0,
                frameTimer: 0,
                collected: false
            });
        }

        function updateCoins(dt, pixelsPerSecond) {
            // Random coin spawn
            if (Math.random() < 0.6 * dt) { // Time-based spawn chance
                spawnCoin();
            }

            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];

                // Move using delta time (smooth!)
                coin.x -= pixelsPerSecond * dt;

                // Animate (time-based, 25 frames)
                coin.frameTimer += dt;
                if (coin.frameTimer >= 0.04) { // ~25fps animation
                    coin.frameTimer = 0;
                    coin.frame = (coin.frame + 1) % 25;
                }

                // Collect
                if (!coin.collected) {
                    const k = kangaroo.getBounds();
                    if (k.x < coin.x + coin.size && k.x + k.width > coin.x - coin.size &&
                        k.y < coin.y + coin.size && k.y + k.height > coin.y - coin.size) {
                        coin.collected = true;
                        coinsCollected++;
                        totalCoins++;
                        score += 5;
                        playSound('coin');
                        spawnCoinSparkles(coin.x, coin.y);
                    }
                }

                // Remove
                if (coin.x < -50 || coin.collected) {
                    coins.splice(i, 1);
                }
            }
        }

        function drawCoins() {
            coins.forEach(coin => {
                // Round positions to avoid sub-pixel jitter
                const drawX = Math.round(coin.x - coin.size / 2);
                const drawY = Math.round(coin.y - coin.size / 2);

                if (USE_SIMPLE_BOXES) {
                    // Simple gold circle
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(Math.round(coin.x), Math.round(coin.y), coin.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#FFA500';
                    ctx.beginPath();
                    ctx.arc(Math.round(coin.x), Math.round(coin.y), coin.size / 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (assets.coin) {
                    // Animated coin sprite
                    const srcX = coin.frame * 64;
                    ctx.drawImage(
                        assets.coin,
                        srcX, 0, 64, 64,
                        drawX, drawY,
                        coin.size, coin.size
                    );
                }

                // Debug: draw coin hitbox
                if (DEBUG) {
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(drawX, drawY, coin.size, coin.size);
                }
            });
        }

        // === COLLISION ===
        function checkCollisions() {
            const k = kangaroo.getBounds();

            for (const obs of obstacles) {
                const o = {
                    x: obs.x - obs.width / 2 + 10,
                    y: obs.y - obs.height + 10,
                    width: obs.width - 20,
                    height: obs.height - 20
                };

                if (k.x < o.x + o.width && k.x + k.width > o.x &&
                    k.y < o.y + o.height && k.y + k.height > o.y) {
                    return true;
                }
            }
            return false;
        }

        // === BACKGROUND ===
        function drawBackground() {
            // Clean blue sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
            gradient.addColorStop(0, '#4A90D9');   // Deeper blue at top
            gradient.addColorStop(0.5, '#87CEEB'); // Sky blue
            gradient.addColorStop(1, '#B0E0E6');  // Lighter near horizon
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, GROUND_Y);

            // Simple clouds (slow parallax)
            if (assets.clouds) {
                const cloudWidth = assets.clouds.width;
                const cloudSpeed = gameSpeed * 60 * 0.1 * deltaTime;
                cloudsOffset = (cloudsOffset + cloudSpeed) % cloudWidth;

                ctx.globalAlpha = 0.6;
                for (let x = -cloudsOffset; x < CANVAS_WIDTH + cloudWidth; x += cloudWidth) {
                    ctx.drawImage(assets.clouds, Math.round(x), 40, cloudWidth * 0.8, 80);
                }
                ctx.globalAlpha = 1;
            }

            // Distant hills (slow parallax)
            if (assets.hills) {
                const hillWidth = assets.hills.width * 0.4;
                const hillSpeed = gameSpeed * 60 * 0.15 * deltaTime;
                hillsOffset = (hillsOffset + hillSpeed) % hillWidth;

                ctx.globalAlpha = 0.5;
                for (let x = -hillsOffset; x < CANVAS_WIDTH + hillWidth; x += hillWidth) {
                    ctx.drawImage(assets.hills, Math.round(x), GROUND_Y - 120, hillWidth, 130);
                }
                ctx.globalAlpha = 1;
            }
        }

        function drawGround() {
            // Ground texture
            if (assets.ground) {
                const groundWidth = assets.ground.width;
                const groundHeight = CANVAS_HEIGHT - GROUND_Y + 20;
                const groundSpeed = gameSpeed * 60 * deltaTime;
                groundOffset = (groundOffset + groundSpeed) % groundWidth;

                for (let x = -groundOffset; x < CANVAS_WIDTH + groundWidth; x += groundWidth) {
                    ctx.drawImage(
                        assets.ground,
                        0, 0, assets.ground.width, assets.ground.height,
                        Math.round(x), GROUND_Y, groundWidth, groundHeight
                    );
                }
            } else {
                // Fallback: nice earthy ground
                ctx.fillStyle = '#C4A574';
                ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, CANVAS_HEIGHT - GROUND_Y);
            }

            // Ground line (darker edge at top of ground)
            ctx.fillStyle = '#8B7355';
            ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, 4);
        }

        // === UI ===
        function drawUI() {
            // Modern score panel (top right)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            roundRect(ctx, CANVAS_WIDTH - 160, 10, 150, 70, 12);
            ctx.fill();

            ctx.fillStyle = '#FFF';
            ctx.font = '600 28px Poppins';
            ctx.textAlign = 'right';
            ctx.fillText(Math.floor(score), CANVAS_WIDTH - 25, 45);

            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.font = '400 14px Poppins';
            ctx.fillText(`BEST: ${Math.floor(highScore)}`, CANVAS_WIDTH - 25, 68);

            // Modern coin panel (top left)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            roundRect(ctx, 10, 10, 130, 70, 12);
            ctx.fill();

            // Coin icon (circle)
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(40, 35, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
            ctx.arc(40, 35, 10, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#FFF';
            ctx.font = '700 22px Poppins';
            ctx.textAlign = 'left';
            ctx.fillText(totalCoins, 65, 42);

            ctx.fillStyle = '#4ADE80';
            ctx.font = '600 14px Poppins';
            ctx.fillText(`+${coinsCollected}`, 65, 62);

            // Debug panel
            if (DEBUG) {
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(10, CANVAS_HEIGHT - 130, 280, 120);

                ctx.fillStyle = '#0F0';
                ctx.font = '12px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`DEBUG MODE | FPS: ${fps} | dt: ${(deltaTime * 1000).toFixed(1)}ms`, 20, CANVAS_HEIGHT - 112);
                ctx.fillText(`Speed: ${gameSpeed.toFixed(2)} | px/s: ${(gameSpeed * 60).toFixed(0)}`, 20, CANVAS_HEIGHT - 96);
                ctx.fillText(`Obstacles: ${obstacles.length} | Coins: ${coins.length}`, 20, CANVAS_HEIGHT - 80);
                ctx.fillText(`Kangaroo Y: ${kangaroo.y.toFixed(0)} | onGround: ${kangaroo.onGround}`, 20, CANVAS_HEIGHT - 64);
                ctx.fillText(`Assets: ${Object.keys(assets).length}/${assetList.length}`, 20, CANVAS_HEIGHT - 48);
                ctx.fillStyle = '#FF0';
                ctx.fillText(`Using delta time for smooth movement`, 20, CANVAS_HEIGHT - 32);
                ctx.fillStyle = '#0FF';
                ctx.fillText(`USE_SIMPLE_BOXES: ${USE_SIMPLE_BOXES}`, 20, CANVAS_HEIGHT - 16);
            }
        }

        function drawStartScreen() {
            // Dark overlay with gradient
            const overlay = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
            overlay.addColorStop(0, 'rgba(15, 23, 42, 0.9)');
            overlay.addColorStop(1, 'rgba(15, 23, 42, 0.7)');
            ctx.fillStyle = overlay;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.textAlign = 'center';

            // Title with gradient effect
            ctx.font = '800 56px Poppins';
            ctx.fillStyle = '#FFF';
            ctx.fillText('KANGAROO', CANVAS_WIDTH / 2, 170);

            // Accent color for "HOP"
            ctx.fillStyle = '#4ADE80';
            ctx.fillText('HOP', CANVAS_WIDTH / 2, 230);

            // Play button
            const btnX = CANVAS_WIDTH / 2 - 100;
            const btnY = 300;
            const btnW = 200;
            const btnH = 55;

            // Button gradient
            const btnGrad = ctx.createLinearGradient(btnX, btnY, btnX, btnY + btnH);
            btnGrad.addColorStop(0, '#4ADE80');
            btnGrad.addColorStop(1, '#22C55E');
            ctx.fillStyle = btnGrad;
            roundRect(ctx, btnX, btnY, btnW, btnH, 27);
            ctx.fill();

            ctx.fillStyle = '#FFF';
            ctx.font = '700 20px Poppins';
            ctx.fillText('TAP TO PLAY', CANVAS_WIDTH / 2, btnY + 35);

            // Stats
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = '400 16px Poppins';
            ctx.fillText(`Best Score: ${highScore}  â€¢  Coins: ${totalCoins}`, CANVAS_WIDTH / 2, 420);

            // Hint
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.font = '400 14px Poppins';
            ctx.fillText('Press SPACE or Click to jump â€¢ Double tap for double jump', CANVAS_WIDTH / 2, 550);
        }

        function drawGameOver() {
            // Dark overlay
            const overlay = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
            overlay.addColorStop(0, 'rgba(15, 23, 42, 0.95)');
            overlay.addColorStop(1, 'rgba(15, 23, 42, 0.85)');
            ctx.fillStyle = overlay;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.textAlign = 'center';

            // Game Over text
            ctx.font = '800 42px Poppins';
            ctx.fillStyle = '#F87171';
            ctx.fillText('GAME OVER', CANVAS_WIDTH / 2, 140);

            // Score card
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            roundRect(ctx, CANVAS_WIDTH / 2 - 120, 170, 240, 140, 16);
            ctx.fill();

            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = '400 14px Poppins';
            ctx.fillText('SCORE', CANVAS_WIDTH / 2, 200);

            ctx.fillStyle = '#FFF';
            ctx.font = '800 48px Poppins';
            ctx.fillText(Math.floor(score), CANVAS_WIDTH / 2, 255);

            // New high score badge
            if (score >= highScore && score > 0) {
                ctx.fillStyle = '#FBBF24';
                ctx.font = '700 16px Poppins';
                ctx.fillText('ðŸ† NEW BEST!', CANVAS_WIDTH / 2, 290);
            }

            // Coins earned
            ctx.fillStyle = '#4ADE80';
            ctx.font = '600 18px Poppins';
            ctx.fillText(`+${coinsCollected} coins`, CANVAS_WIDTH / 2, 360);

            // Retry button
            const btnX = CANVAS_WIDTH / 2 - 90;
            const btnY = 400;
            const btnW = 180;
            const btnH = 50;

            const btnGrad = ctx.createLinearGradient(btnX, btnY, btnX, btnY + btnH);
            btnGrad.addColorStop(0, '#4ADE80');
            btnGrad.addColorStop(1, '#22C55E');
            ctx.fillStyle = btnGrad;
            roundRect(ctx, btnX, btnY, btnW, btnH, 25);
            ctx.fill();

            ctx.fillStyle = '#FFF';
            ctx.font = '700 18px Poppins';
            ctx.fillText('PLAY AGAIN', CANVAS_WIDTH / 2, btnY + 32);

            // Hint
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.font = '400 13px Poppins';
            ctx.fillText('Press SPACE or Click', CANVAS_WIDTH / 2, 500);
        }

        // === GAME LOOP ===
        function reset() {
            kangaroo.y = GROUND_Y;
            kangaroo.velocityY = 0;
            kangaroo.onGround = true;
            kangaroo.frame = 0;
            kangaroo.isDead = false;
            kangaroo.deathRotation = 0;
            kangaroo.deathVelocityY = 0;
            kangaroo.scaleX = 1;
            kangaroo.scaleY = 1;
            obstacles = [];
            coins = [];
            particles = [];
            gameSpeed = INITIAL_SPEED;
            score = 0;
            coinsCollected = 0;
            gameOver = false;
            showGameOverUI = false;
            gameOverTimer = 0;
            lastObstacleTime = Date.now();
        }

        function update(dt) {
            // Always update these (even during game over)
            updateScreenShake(dt);
            updateParticles(dt);

            // Update kangaroo death animation even when game over
            if (gameOver && kangaroo.isDead) {
                kangaroo.update(dt);

                // Delay showing game over UI
                if (!showGameOverUI) {
                    gameOverTimer += dt;
                    if (gameOverTimer >= 1.2) { // 1.2 second delay
                        showGameOverUI = true;
                    }
                }
            }

            if (!gameStarted || gameOver) return;

            // Use delta time (dt) for consistent movement
            // Convert gameSpeed from "pixels per frame" to "pixels per second"
            const pixelsPerSecond = gameSpeed * 60; // Assume 60fps base

            kangaroo.update(dt);
            updateObstacles(dt, pixelsPerSecond);
            updateCoins(dt, pixelsPerSecond);

            // Speed up gradually
            gameSpeed = Math.min(MAX_SPEED, gameSpeed + SPEED_INCREMENT);

            // Score increases over time
            score += 6 * dt; // ~6 points per second

            // Collision check
            if (checkCollisions()) {
                gameOver = true;
                playSound('collision');
                playSound('gameOver');
                // Trigger death animation
                kangaroo.die();
                if (score > highScore) {
                    highScore = Math.floor(score);
                    localStorage.setItem('kangaroo_raw_high', highScore);
                }
                localStorage.setItem('kangaroo_raw_coins', totalCoins);
            }
        }

        function draw() {
            // Clear entire canvas first (important for smooth rendering!)
            ctx.fillStyle = '#4A90D9';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Apply screen shake
            const shake = getShakeOffset();
            ctx.save();
            ctx.translate(shake.x, shake.y);

            drawBackground();
            drawGround();

            if (!gameStarted) {
                kangaroo.draw();
                drawStartScreen();
            } else if (gameOver) {
                drawObstacles();
                drawCoins();
                drawParticles();
                kangaroo.draw();
                drawUI();
                // Only show game over UI after delay
                if (showGameOverUI) {
                    drawGameOver();
                }
            } else {
                drawObstacles();
                drawCoins();
                drawParticles();
                kangaroo.draw();
                drawUI();
            }

            ctx.restore(); // End screen shake
        }

        function gameLoop(currentTime) {
            // Calculate delta time (in seconds)
            deltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;

            // Cap delta time to prevent huge jumps (e.g., when tab inactive)
            deltaTime = Math.min(deltaTime, 0.1);

            // FPS calculation
            frameCount++;
            const now = Date.now();
            if (now - lastFpsUpdate >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = now;
            }

            update(deltaTime);
            draw();
            requestAnimationFrame(gameLoop);
        }

        // === INPUT ===
        function handleInput() {
            if (!gameStarted) {
                gameStarted = true;
                reset();
            } else if (gameOver) {
                // Only allow restart after UI shows
                if (showGameOverUI) {
                    reset();
                }
            } else {
                kangaroo.jump();
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault();
                handleInput();
            }
        });

        canvas.addEventListener('click', handleInput);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleInput();
        });

        // === START ===
        loadAssets(() => {
            gameLoop();
        });
    </script>
</body>
</html>
