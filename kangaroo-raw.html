<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kangaroo Hop</title>
    <!-- Modern Google Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            font-family: 'Poppins', sans-serif;
        }
        #gameContainer {
            position: relative;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5), 0 0 40px rgba(79, 172, 254, 0.15);
        }
        canvas {
            display: block;
            border-radius: 16px;
            cursor: pointer;
            /* Force GPU acceleration */
            transform: translateZ(0);
            will-change: transform;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="game" width="800" height="600"></canvas>
        <div id="loading">Loading...</div>
    </div>

    <script>
        // ============================================
        // KANGAROO HOP - Raw Canvas Edition
        // No frameworks, just pure JavaScript
        // ============================================

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d', {
            alpha: false,        // Disable transparency for performance
            desynchronized: true // Reduce latency
        });
        const loadingEl = document.getElementById('loading');

        // === AUDIO ===
        const sounds = {
            jump: new Audio('assets/audio/sfx/jump.mp3'),
            doubleJump: new Audio('assets/audio/sfx/double_jump.mp3'),
            coin: new Audio('assets/audio/sfx/coin_collect.mp3'),
            collision: new Audio('assets/audio/sfx/collision.mp3'),
            gameOver: new Audio('assets/audio/sfx/game_over.mp3')
        };

        // Set volumes
        sounds.jump.volume = 0.5;
        sounds.doubleJump.volume = 0.5;
        sounds.coin.volume = 0.7;
        sounds.collision.volume = 0.6;
        sounds.gameOver.volume = 0.8;

        function playSound(name) {
            if (!soundEnabled) return; // Respect sound toggle
            const sound = sounds[name];
            if (sound) {
                sound.currentTime = 0; // Rewind to start
                sound.play().catch(() => {}); // Ignore autoplay errors
            }
        }

        // Helper: Draw rounded rectangle
        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        // === CONSTANTS ===
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const GROUND_Y = 500;
        const GRAVITY = 0.8;
        const JUMP_FORCE = -20;
        const INITIAL_SPEED = 6;
        const MAX_SPEED = 14;
        const SPEED_INCREMENT = 0.002;

        // === ASSETS ===
        const assets = {};
        const assetList = [
            { name: 'kangaroo', src: 'assets/images/kangaroos.png' },
            { name: 'ground', src: 'assets/images/parallax/_01_ground.png' },
            { name: 'background', src: 'assets/images/parallax/_11_background.png' },
            { name: 'clouds', src: 'assets/images/parallax/_08_clouds.png' },
            { name: 'hills', src: 'assets/images/parallax/_06_hill2.png' },
            { name: 'rock', src: 'assets/images/rock.png' },
            { name: 'cactus', src: 'assets/images/cactus.png' },
            { name: 'snakeLog', src: 'assets/images/snake_log.png' },
            { name: 'emu', src: 'assets/images/emu_sheet.png' },
            { name: 'magpie', src: 'assets/images/magpie_sheet.png' },
            { name: 'coin', src: 'assets/images/coin/coin-64x64.png' },
            // Powerups
            { name: 'powerupShield', src: 'assets/images/powerups/heart_glow.png' },
            { name: 'powerupMagnet', src: 'assets/images/powerups/magnet_glow.png' },
            { name: 'powerupDoubleJump', src: 'assets/images/powerups/star_glow.png' }
        ];

        function loadAssets(callback) {
            let loaded = 0;
            const total = assetList.length;

            assetList.forEach(asset => {
                const img = new Image();
                img.onload = () => {
                    assets[asset.name] = img;
                    loaded++;
                    console.log(`‚úì Loaded: ${asset.name} (${img.width}x${img.height})`);
                    loadingEl.textContent = `Loading... ${Math.floor(loaded / total * 100)}%`;
                    if (loaded === total) {
                        loadingEl.style.display = 'none';
                        console.log('All assets loaded:', Object.keys(assets));
                        callback();
                    }
                };
                img.onerror = () => {
                    console.error(`‚úó Failed to load: ${asset.name} from ${asset.src}`);
                    loaded++;
                    if (loaded === total) {
                        loadingEl.style.display = 'none';
                        callback();
                    }
                };
                img.src = asset.src;
            });
        }

        // FPS tracking
        let fps = 0;
        let frameCount = 0;
        let lastFpsUpdate = Date.now();

        // Delta time for smooth movement
        let lastFrameTime = performance.now();
        let deltaTime = 0;

        // === DEBUG MODE ===
        const DEBUG = false; // Set to false to hide debug info

        // === PARTICLES ===
        let particles = [];

        function spawnDustParticles(x, y) {
            // Spawn 8-12 dust particles
            const count = 8 + Math.floor(Math.random() * 5);
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 40,
                    y: y,
                    vx: (Math.random() - 0.5) * 150,
                    vy: -Math.random() * 80 - 20,
                    size: 4 + Math.random() * 8,
                    life: 0.4 + Math.random() * 0.3,
                    maxLife: 0.4 + Math.random() * 0.3,
                    color: Math.random() > 0.5 ? '#C4A574' : '#A68B5B',
                    type: 'dust'
                });
            }
        }

        function spawnCoinSparkles(x, y) {
            // Spawn golden sparkles
            const count = 12 + Math.floor(Math.random() * 6);
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
                const speed = 100 + Math.random() * 150;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 3 + Math.random() * 5,
                    life: 0.3 + Math.random() * 0.3,
                    maxLife: 0.3 + Math.random() * 0.3,
                    color: Math.random() > 0.5 ? '#FFD700' : '#FFF176',
                    type: 'sparkle'
                });
            }
        }

        // Screen shake
        let screenShake = { intensity: 0, duration: 0 };

        function triggerScreenShake(intensity, duration) {
            screenShake.intensity = intensity;
            screenShake.duration = duration;
        }

        function updateScreenShake(dt) {
            if (screenShake.duration > 0) {
                screenShake.duration -= dt;
            } else {
                screenShake.intensity = 0;
            }
        }

        function getShakeOffset() {
            if (screenShake.intensity > 0) {
                return {
                    x: (Math.random() - 0.5) * screenShake.intensity * 2,
                    y: (Math.random() - 0.5) * screenShake.intensity * 2
                };
            }
            return { x: 0, y: 0 };
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];

                // Move
                p.x += p.vx * dt;
                p.y += p.vy * dt;

                // Gravity only for dust, not sparkles
                if (p.type === 'dust') {
                    p.vy += 200 * dt;
                } else if (p.type === 'sparkle') {
                    // Sparkles slow down
                    p.vx *= 0.95;
                    p.vy *= 0.95;
                }

                // Fade out
                p.life -= dt;

                // Remove dead particles
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                const alpha = p.life / p.maxLife;

                if (p.type === 'sparkle') {
                    // Sparkles are brighter and have glow effect
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(Math.round(p.x), Math.round(p.y), p.size * alpha * 1.5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(Math.round(p.x), Math.round(p.y), p.size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Dust particles
                    ctx.globalAlpha = alpha * 0.7;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(Math.round(p.x), Math.round(p.y), p.size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            ctx.globalAlpha = 1;
        }

        // === GAME STATE ===
        let gameSpeed = INITIAL_SPEED;
        let score = 0;
        let highScore = parseInt(localStorage.getItem('kangaroo_raw_high')) || 0;
        let coinsCollected = 0;
        let totalCoins = parseInt(localStorage.getItem('kangaroo_raw_coins')) || 0;
        let gameOver = false;
        let showGameOverUI = false;
        let gameOverTimer = 0;
        let gameStarted = false;

        // Menu animation
        let menuKangarooY = 0;
        let menuKangarooVel = 0;
        let menuBounceTimer = 0;
        let soundEnabled = true;
        let groundOffset = 0;
        let cloudsOffset = 0;
        let hillsOffset = 0;

        // === KANGAROO ===
        const DOUBLE_JUMP_FORCE = -17; // Slightly weaker than first jump

        const kangaroo = {
            x: 100,
            y: GROUND_Y,
            width: 110,
            height: 140,
            velocityY: 0,
            onGround: true,
            wasOnGround: true, // Track previous frame
            canDoubleJump: false, // Can we do a second jump?
            frame: 0,
            frameTimer: 0,
            frameDelay: 4, // Frames between animation updates

            // Squash & stretch
            scaleX: 1,
            scaleY: 1,
            squashTime: 0,

            // Death animation
            isDead: false,
            deathRotation: 0,
            deathVelocityY: 0,

            // Sprite sheet: 6 columns x 2 rows = 12 frames, each 128x128
            spriteWidth: 128,
            spriteHeight: 128,
            totalFrames: 12,

            update(dt) {
                // Handle death animation separately
                if (this.isDead) {
                    this.updateDeath(dt);
                    return;
                }

                this.wasOnGround = this.onGround;

                // Gravity (using delta time)
                const gravityPerSecond = GRAVITY * 60; // Convert to per-second
                this.velocityY += gravityPerSecond * dt;
                this.y += this.velocityY * dt * 60;

                // Ground collision
                if (this.y >= GROUND_Y) {
                    this.y = GROUND_Y;
                    this.velocityY = 0;
                    this.onGround = true;
                    this.canDoubleJump = false; // Reset on landing

                    // Trigger squash on landing
                    if (!this.wasOnGround) {
                        this.squashTime = 0.15; // Duration of squash
                        this.scaleX = 1.3;  // Wider
                        this.scaleY = 0.7;  // Shorter
                        // Spawn dust particles!
                        spawnDustParticles(this.x, GROUND_Y);
                    }
                }

                // Animate squash back to normal
                if (this.squashTime > 0) {
                    this.squashTime -= dt;
                    // Lerp back to normal
                    this.scaleX += (1 - this.scaleX) * 10 * dt;
                    this.scaleY += (1 - this.scaleY) * 10 * dt;
                } else {
                    this.scaleX = 1;
                    this.scaleY = 1;
                }

                // Animation (time-based)
                this.frameTimer += dt;
                if (this.frameTimer >= 0.05) { // ~20fps animation
                    this.frameTimer = 0;
                    if (this.onGround) {
                        this.frame = (this.frame + 1) % this.totalFrames;
                    }
                }
            },

            die() {
                this.isDead = true;
                this.deathVelocityY = -10; // Pop up
                this.deathRotation = 0;
            },

            updateDeath(dt) {
                if (!this.isDead) return;

                // Fall and spin
                this.deathVelocityY += 30 * dt; // Gravity
                this.y += this.deathVelocityY;
                this.deathRotation += 8 * dt; // Spin

                // Fade out or fall off screen
            },

            jump() {
                if (this.isDead) return; // Can't jump when dead
                if (this.onGround) {
                    // First jump
                    this.velocityY = JUMP_FORCE;
                    this.onGround = false;
                    this.canDoubleJump = true; // Enable double jump
                    this.frame = 3; // Jump frame
                    playSound('jump');
                    // Stretch effect (taller, narrower)
                    this.scaleX = 0.8;
                    this.scaleY = 1.2;
                    this.squashTime = 0.1;
                } else if (this.canDoubleJump || activePowerups.doubleJump.active) {
                    // Double jump! (unlimited if powerup active)
                    this.velocityY = DOUBLE_JUMP_FORCE;
                    if (!activePowerups.doubleJump.active) {
                        this.canDoubleJump = false; // Only use up if no powerup
                    }
                    this.frame = 3; // Reset jump frame
                    playSound('doubleJump');
                    // Stretch effect
                    this.scaleX = 0.8;
                    this.scaleY = 1.2;
                    this.squashTime = 0.1;
                }
            },

            draw() {
                // Calculate scaled dimensions
                const scaledWidth = this.width * this.scaleX;
                const scaledHeight = this.height * this.scaleY;

                // Round positions to avoid sub-pixel jitter
                const drawX = Math.round(this.x);
                const drawY = Math.round(this.y);

                ctx.save();

                // Draw powerup aura/glow
                if (!this.isDead) {
                    const glowTime = performance.now() / 1000;
                    let glowColors = [];

                    if (activePowerups.shield.active) glowColors.push('#FF69B4');
                    if (activePowerups.magnet.active) glowColors.push('#00BFFF');
                    if (activePowerups.doubleJump.active) glowColors.push('#00FF00');

                    if (glowColors.length > 0) {
                        const glowIndex = Math.floor(glowTime * 3) % glowColors.length;
                        const glowColor = glowColors[glowIndex];
                        const glowSize = 20 + Math.sin(glowTime * 5) * 8;

                        ctx.globalAlpha = 0.4 + Math.sin(glowTime * 4) * 0.15;
                        ctx.fillStyle = glowColor;
                        ctx.beginPath();
                        ctx.ellipse(
                            drawX,
                            drawY - scaledHeight * 0.35,  // Lower center (kangaroo art sits in bottom of sprite)
                            scaledWidth / 2 + glowSize,
                            scaledHeight / 2 + glowSize * 0.5,
                            0, 0, Math.PI * 2
                        );
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }
                }

                // Apply death rotation if dead
                if (this.isDead) {
                    ctx.translate(drawX, drawY - scaledHeight / 2);
                    ctx.rotate(this.deathRotation);
                    ctx.translate(-drawX, -(drawY - scaledHeight / 2));
                }

                if (USE_SIMPLE_BOXES) {
                    // Simple brown box for kangaroo
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(drawX - scaledWidth / 2, drawY - scaledHeight, scaledWidth, scaledHeight);
                    ctx.fillStyle = '#FFF';
                    ctx.font = 'bold 14px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('ROO', drawX, drawY - scaledHeight / 2);
                    ctx.textAlign = 'left';
                } else if (assets.kangaroo) {
                    const col = this.frame % 6;
                    const row = Math.floor(this.frame / 6);
                    const srcX = col * this.spriteWidth;
                    const srcY = row * this.spriteHeight;

                    ctx.drawImage(
                        assets.kangaroo,
                        srcX, srcY, this.spriteWidth, this.spriteHeight,
                        drawX - scaledWidth / 2, drawY - scaledHeight,
                        scaledWidth, scaledHeight
                    );
                }

                ctx.restore();

                // Debug: draw hitbox
                if (DEBUG) {
                    const bounds = this.getBounds();
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(
                        Math.round(bounds.x),
                        Math.round(bounds.y),
                        bounds.width,
                        bounds.height
                    );

                    // Show frame number
                    ctx.fillStyle = '#00FF00';
                    ctx.font = '12px monospace';
                    ctx.fillText(`F:${this.frame}`, Math.round(this.x) - 15, drawY - 5);
                }
            },

            getBounds() {
                // Smaller hitbox for fair gameplay
                const padding = 15;
                const reducedHeight = (this.height - padding * 2) * 0.5; // 50% shorter
                return {
                    x: this.x - this.width / 2 + padding,
                    y: this.y - reducedHeight - padding, // Anchored to bottom
                    width: this.width - padding * 2,
                    height: reducedHeight
                };
            }
        };

        // === OBSTACLES ===
        let obstacles = [];
        let lastObstacleTime = 0;
        let obstacleInterval = 1500;

        const obstacleTypes = [
            { name: 'rock', asset: 'rock', width: 85, height: 70, animated: false },
            { name: 'cactus', asset: 'cactus', width: 70, height: 100, animated: false },
            { name: 'snakeLog', asset: 'snakeLog', width: 110, height: 70, animated: false },
            { name: 'emu', asset: 'emu', width: 110, height: 125, animated: true, frames: 4, frameWidth: 128, frameHeight: 128 },
            { name: 'magpie', asset: 'magpie', width: 80, height: 70, animated: true, frames: 4, frameWidth: 128, frameHeight: 128, flying: true }
        ];

        function spawnObstacle() {
            // Pick random type (magpie less common)
            let typeIndex;
            const rand = Math.random();
            if (rand < 0.12) {
                typeIndex = 4; // Magpie (12%)
            } else if (rand < 0.25) {
                typeIndex = 3; // Emu (13%)
            } else {
                typeIndex = Math.floor(Math.random() * 3); // Rock, cactus, or snake log (75%)
            }

            const type = obstacleTypes[typeIndex];
            const obstacle = {
                x: CANVAS_WIDTH + 50,
                y: type.flying ? GROUND_Y - 80 - Math.random() * 60 : GROUND_Y,
                width: type.width,
                height: type.height,
                type: type,
                frame: 0,
                frameTimer: 0,
                // Magpie swoop
                swooping: false,
                swoopTarget: GROUND_Y - 30
            };

            obstacles.push(obstacle);

            // Maybe spawn a coin nearby
            if (Math.random() < 0.6) {
                spawnCoin(obstacle.x + 50 + Math.random() * 100);
            }
        }

        function updateObstacles(dt, pixelsPerSecond) {
            const now = Date.now();

            // Spawn new obstacles
            if (now - lastObstacleTime > obstacleInterval) {
                spawnObstacle();
                lastObstacleTime = now;
                // Vary interval
                obstacleInterval = 1200 + Math.random() * 800 - (score * 0.5);
                obstacleInterval = Math.max(600, obstacleInterval);
            }

            // Update existing obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];

                // Move using delta time (smooth!)
                obs.x -= pixelsPerSecond * dt;

                // Animate (time-based)
                if (obs.type.animated && obs.type.frames > 0) {
                    obs.frameTimer += dt;
                    if (obs.frameTimer >= 0.1) { // 10fps animation
                        obs.frameTimer = 0;
                        obs.frame = (obs.frame + 1) % obs.type.frames;
                    }
                }

                // Magpie swoop AI
                if (obs.type.flying && !obs.swooping && obs.x < kangaroo.x + 200 && score > 500) {
                    if (Math.random() < 0.02) {
                        obs.swooping = true;
                    }
                }
                if (obs.swooping) {
                    if (obs.y < obs.swoopTarget) {
                        obs.y += 180 * dt; // 180 pixels per second swoop
                    }
                }

                // Remove off-screen
                if (obs.x < -100) {
                    obstacles.splice(i, 1);
                    score += 10;
                }
            }
        }

        // Toggle to use simple boxes instead of images
        const USE_SIMPLE_BOXES = false;

        const obstacleColors = {
            rock: '#666666',
            cactus: '#228B22',
            snakeLog: '#8B4513',
            emu: '#4169E1',
            magpie: '#333333'
        };

        function drawObstacles() {
            obstacles.forEach(obs => {
                if (USE_SIMPLE_BOXES) {
                    // Simple colored box
                    ctx.fillStyle = obstacleColors[obs.type.name] || '#FF0000';
                    ctx.fillRect(
                        Math.round(obs.x - obs.width / 2),
                        Math.round(obs.y - obs.height),
                        obs.width,
                        obs.height
                    );

                    // Label
                    ctx.fillStyle = '#FFF';
                    ctx.font = 'bold 12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(obs.type.name, Math.round(obs.x), Math.round(obs.y - obs.height / 2));
                    ctx.textAlign = 'left';
                } else {
                    // Original image-based rendering
                    const asset = assets[obs.type.asset];
                    if (!asset) return;

                    try {
                        if (obs.type.animated) {
                            const safeFrame = Math.max(0, Math.min(obs.frame, obs.type.frames - 1));
                            const srcX = safeFrame * obs.type.frameWidth;

                            // Flip magpie horizontally (it faces right in sprite, needs to face left)
                            if (obs.type.flying) {
                                ctx.save();
                                ctx.scale(-1, 1);
                                ctx.drawImage(
                                    asset,
                                    srcX, 0, obs.type.frameWidth, obs.type.frameHeight,
                                    -(obs.x + obs.width / 2), obs.y - obs.height,
                                    obs.width, obs.height
                                );
                                ctx.restore();
                            } else {
                                ctx.drawImage(
                                    asset,
                                    srcX, 0, obs.type.frameWidth, obs.type.frameHeight,
                                    obs.x - obs.width / 2, obs.y - obs.height,
                                    obs.width, obs.height
                                );
                            }
                        } else {
                            ctx.drawImage(
                                asset,
                                obs.x - obs.width / 2, obs.y - obs.height,
                                obs.width, obs.height
                            );
                        }
                    } catch (e) {
                        console.error('Draw error:', obs.type.name, e);
                    }
                }

                // Debug: draw hitbox
                if (DEBUG) {
                    const hitbox = {
                        x: obs.x - obs.width / 2 + 10,
                        y: obs.y - obs.height + 10,
                        width: obs.width - 20,
                        height: obs.height - 20
                    };
                    ctx.strokeStyle = '#FF0000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(
                        Math.round(hitbox.x),
                        Math.round(hitbox.y),
                        hitbox.width,
                        hitbox.height
                    );
                }
            });
        }

        // === COINS ===
        let coins = [];

        function spawnCoin(x) {
            coins.push({
                x: x || CANVAS_WIDTH + Math.random() * 200,
                y: GROUND_Y - 50 - Math.random() * 80,
                size: 40,
                frame: 0,
                frameTimer: 0,
                collected: false
            });
        }

        function updateCoins(dt, pixelsPerSecond) {
            // Random coin spawn
            if (Math.random() < 0.6 * dt) { // Time-based spawn chance
                spawnCoin();
            }

            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];

                // Move using delta time (smooth!)
                coin.x -= pixelsPerSecond * dt;

                // Animate (time-based, 25 frames)
                coin.frameTimer += dt;
                if (coin.frameTimer >= 0.04) { // ~25fps animation
                    coin.frameTimer = 0;
                    coin.frame = (coin.frame + 1) % 25;
                }

                // Collect
                if (!coin.collected) {
                    const k = kangaroo.getBounds();
                    if (k.x < coin.x + coin.size && k.x + k.width > coin.x - coin.size &&
                        k.y < coin.y + coin.size && k.y + k.height > coin.y - coin.size) {
                        coin.collected = true;
                        coinsCollected++;
                        totalCoins++;
                        score += 5;
                        playSound('coin');
                        spawnCoinSparkles(coin.x, coin.y);
                    }
                }

                // Remove
                if (coin.x < -50 || coin.collected) {
                    coins.splice(i, 1);
                }
            }
        }

        function drawCoins() {
            coins.forEach(coin => {
                // Round positions to avoid sub-pixel jitter
                const drawX = Math.round(coin.x - coin.size / 2);
                const drawY = Math.round(coin.y - coin.size / 2);

                if (USE_SIMPLE_BOXES) {
                    // Simple gold circle
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(Math.round(coin.x), Math.round(coin.y), coin.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#FFA500';
                    ctx.beginPath();
                    ctx.arc(Math.round(coin.x), Math.round(coin.y), coin.size / 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (assets.coin) {
                    // Animated coin sprite
                    const srcX = coin.frame * 64;
                    ctx.drawImage(
                        assets.coin,
                        srcX, 0, 64, 64,
                        drawX, drawY,
                        coin.size, coin.size
                    );
                }

                // Debug: draw coin hitbox
                if (DEBUG) {
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(drawX, drawY, coin.size, coin.size);
                }
            });
        }

        // === POWERUPS ===
        let powerups = [];
        const POWERUP_DURATION = 10; // seconds
        const POWERUP_SIZE = 50;

        // Active powerup states
        const activePowerups = {
            shield: { active: false, timer: 0 },
            magnet: { active: false, timer: 0 },
            doubleJump: { active: false, timer: 0 }
        };

        const powerupTypes = [
            { name: 'shield', asset: 'powerupShield', color: '#FF69B4' },      // Pink
            { name: 'magnet', asset: 'powerupMagnet', color: '#00BFFF' },      // Blue
            { name: 'doubleJump', asset: 'powerupDoubleJump', color: '#00FF00' } // Green
        ];

        function spawnPowerup(x) {
            const type = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
            powerups.push({
                x: x || CANVAS_WIDTH + Math.random() * 100,
                y: GROUND_Y - 80 - Math.random() * 60,
                size: POWERUP_SIZE,
                type: type,
                collected: false,
                bobOffset: Math.random() * Math.PI * 2, // For floating animation
                glowPhase: 0
            });
        }

        function updatePowerups(dt, pixelsPerSecond) {
            // Random powerup spawn (less frequent than coins)
            if (Math.random() < 0.15 * dt && score > 100) {
                spawnPowerup();
            }

            // Update active powerup timers
            for (const key in activePowerups) {
                if (activePowerups[key].active) {
                    activePowerups[key].timer -= dt;
                    if (activePowerups[key].timer <= 0) {
                        activePowerups[key].active = false;
                        activePowerups[key].timer = 0;
                    }
                }
            }

            // Update powerup positions
            for (let i = powerups.length - 1; i >= 0; i--) {
                const p = powerups[i];

                // Move
                p.x -= pixelsPerSecond * dt;

                // Floating bob animation
                p.bobOffset += dt * 3;
                p.glowPhase += dt * 5;

                // Collect
                if (!p.collected) {
                    const k = kangaroo.getBounds();
                    const px = p.x - p.size / 2;
                    const py = p.y - p.size / 2 + Math.sin(p.bobOffset) * 8;

                    if (k.x < px + p.size && k.x + k.width > px &&
                        k.y < py + p.size && k.y + k.height > py) {
                        p.collected = true;
                        activatePowerup(p.type.name);
                        playSound('coin'); // Reuse coin sound for now
                        spawnCoinSparkles(p.x, p.y); // Sparkle effect
                    }
                }

                // Remove
                if (p.x < -100 || p.collected) {
                    powerups.splice(i, 1);
                }
            }

            // Magnet effect: attract coins
            if (activePowerups.magnet.active) {
                const magnetRange = 300;
                const magnetForce = 400;
                coins.forEach(coin => {
                    const dx = kangaroo.x - coin.x;
                    const dy = kangaroo.y - 50 - coin.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < magnetRange && dist > 0) {
                        const force = magnetForce * dt * (1 - dist / magnetRange);
                        coin.x += (dx / dist) * force;
                        coin.y += (dy / dist) * force;
                    }
                });
            }
        }

        function activatePowerup(type) {
            activePowerups[type].active = true;
            activePowerups[type].timer = POWERUP_DURATION;
        }

        function drawPowerups() {
            powerups.forEach(p => {
                const bobY = Math.sin(p.bobOffset) * 8;
                const drawX = Math.round(p.x - p.size / 2);
                const drawY = Math.round(p.y - p.size / 2 + bobY);

                // Glow effect
                const glowSize = p.size + 10 + Math.sin(p.glowPhase) * 5;
                ctx.globalAlpha = 0.3 + Math.sin(p.glowPhase) * 0.1;
                ctx.fillStyle = p.type.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y + bobY, glowSize / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;

                // Draw powerup icon
                const asset = assets[p.type.asset];
                if (asset) {
                    ctx.drawImage(asset, drawX, drawY, p.size, p.size);
                } else {
                    // Fallback colored circle
                    ctx.fillStyle = p.type.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y + bobY, p.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Debug hitbox
                if (DEBUG) {
                    ctx.strokeStyle = p.type.color;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(drawX, drawY, p.size, p.size);
                }
            });
        }

        // === COLLISION ===
        function checkCollisions() {
            const k = kangaroo.getBounds();

            for (const obs of obstacles) {
                const o = {
                    x: obs.x - obs.width / 2 + 10,
                    y: obs.y - obs.height + 10,
                    width: obs.width - 20,
                    height: obs.height - 20
                };

                if (k.x < o.x + o.width && k.x + k.width > o.x &&
                    k.y < o.y + o.height && k.y + k.height > o.y) {

                    // Shield protection - consume shield and destroy obstacle
                    if (activePowerups.shield.active) {
                        activePowerups.shield.active = false;
                        activePowerups.shield.timer = 0;
                        // Remove the obstacle we hit
                        const idx = obstacles.indexOf(obs);
                        if (idx > -1) obstacles.splice(idx, 1);
                        // Visual feedback
                        spawnCoinSparkles(obs.x, obs.y - obs.height / 2);
                        playSound('coin');
                        return false; // No death!
                    }
                    return true;
                }
            }
            return false;
        }

        // === BACKGROUND ===
        function drawBackground() {
            // Clean blue sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
            gradient.addColorStop(0, '#4A90D9');   // Deeper blue at top
            gradient.addColorStop(0.5, '#87CEEB'); // Sky blue
            gradient.addColorStop(1, '#B0E0E6');  // Lighter near horizon
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, GROUND_Y);

            // Simple clouds (slow parallax)
            if (assets.clouds) {
                const cloudWidth = assets.clouds.width;
                const cloudSpeed = gameSpeed * 60 * 0.1 * deltaTime;
                cloudsOffset = (cloudsOffset + cloudSpeed) % cloudWidth;

                ctx.globalAlpha = 0.6;
                for (let x = -cloudsOffset; x < CANVAS_WIDTH + cloudWidth; x += cloudWidth) {
                    ctx.drawImage(assets.clouds, Math.round(x), 40, cloudWidth * 0.8, 80);
                }
                ctx.globalAlpha = 1;
            }

            // Distant hills (slow parallax)
            if (assets.hills) {
                const hillWidth = assets.hills.width * 0.4;
                const hillSpeed = gameSpeed * 60 * 0.15 * deltaTime;
                hillsOffset = (hillsOffset + hillSpeed) % hillWidth;

                ctx.globalAlpha = 0.5;
                for (let x = -hillsOffset; x < CANVAS_WIDTH + hillWidth; x += hillWidth) {
                    ctx.drawImage(assets.hills, Math.round(x), GROUND_Y - 120, hillWidth, 130);
                }
                ctx.globalAlpha = 1;
            }
        }

        function drawGround() {
            // Ground texture
            if (assets.ground) {
                const groundWidth = assets.ground.width;
                const groundHeight = CANVAS_HEIGHT - GROUND_Y + 20;
                const groundSpeed = gameSpeed * 60 * deltaTime;
                groundOffset = (groundOffset + groundSpeed) % groundWidth;

                for (let x = -groundOffset; x < CANVAS_WIDTH + groundWidth; x += groundWidth) {
                    ctx.drawImage(
                        assets.ground,
                        0, 0, assets.ground.width, assets.ground.height,
                        Math.round(x), GROUND_Y, groundWidth, groundHeight
                    );
                }
            } else {
                // Fallback: nice earthy ground
                ctx.fillStyle = '#C4A574';
                ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, CANVAS_HEIGHT - GROUND_Y);
            }

            // Ground line (darker edge at top of ground)
            ctx.fillStyle = '#8B7355';
            ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, 4);
        }

        // === UI ===
        function drawUI() {
            // Modern score panel (top right)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            roundRect(ctx, CANVAS_WIDTH - 160, 10, 150, 70, 12);
            ctx.fill();

            ctx.fillStyle = '#FFF';
            ctx.font = '600 28px Poppins';
            ctx.textAlign = 'right';
            ctx.fillText(Math.floor(score), CANVAS_WIDTH - 25, 45);

            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.font = '400 14px Poppins';
            ctx.fillText(`BEST: ${Math.floor(highScore)}`, CANVAS_WIDTH - 25, 68);

            // Modern coin panel (top left)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            roundRect(ctx, 10, 10, 130, 70, 12);
            ctx.fill();

            // Coin icon (circle)
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(40, 35, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
            ctx.arc(40, 35, 10, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#FFF';
            ctx.font = '700 22px Poppins';
            ctx.textAlign = 'left';
            ctx.fillText(totalCoins, 65, 42);

            ctx.fillStyle = '#4ADE80';
            ctx.font = '600 14px Poppins';
            ctx.fillText(`+${coinsCollected}`, 65, 62);

            // Active powerup indicators (below coin panel)
            let powerupY = 95;
            const powerupBarWidth = 100;
            const powerupBarHeight = 8;

            for (const type of powerupTypes) {
                const powerup = activePowerups[type.name];
                if (powerup.active) {
                    // Background bar
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    roundRect(ctx, 15, powerupY, powerupBarWidth + 30, 28, 8);
                    ctx.fill();

                    // Icon circle
                    ctx.fillStyle = type.color;
                    ctx.beginPath();
                    ctx.arc(30, powerupY + 14, 10, 0, Math.PI * 2);
                    ctx.fill();

                    // Progress bar background
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    roundRect(ctx, 48, powerupY + 8, powerupBarWidth, powerupBarHeight, 4);
                    ctx.fill();

                    // Progress bar fill
                    const progress = powerup.timer / POWERUP_DURATION;
                    ctx.fillStyle = type.color;
                    if (progress > 0) {
                        roundRect(ctx, 48, powerupY + 8, powerupBarWidth * progress, powerupBarHeight, 4);
                        ctx.fill();
                    }

                    // Time remaining
                    ctx.fillStyle = '#FFF';
                    ctx.font = '600 10px Poppins';
                    ctx.textAlign = 'right';
                    ctx.fillText(`${Math.ceil(powerup.timer)}s`, 145, powerupY + 18);
                    ctx.textAlign = 'left';

                    powerupY += 35;
                }
            }

            // Debug panel
            if (DEBUG) {
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(10, CANVAS_HEIGHT - 130, 280, 120);

                ctx.fillStyle = '#0F0';
                ctx.font = '12px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`DEBUG MODE | FPS: ${fps} | dt: ${(deltaTime * 1000).toFixed(1)}ms`, 20, CANVAS_HEIGHT - 112);
                ctx.fillText(`Speed: ${gameSpeed.toFixed(2)} | px/s: ${(gameSpeed * 60).toFixed(0)}`, 20, CANVAS_HEIGHT - 96);
                ctx.fillText(`Obstacles: ${obstacles.length} | Coins: ${coins.length}`, 20, CANVAS_HEIGHT - 80);
                ctx.fillText(`Kangaroo Y: ${kangaroo.y.toFixed(0)} | onGround: ${kangaroo.onGround}`, 20, CANVAS_HEIGHT - 64);
                ctx.fillText(`Assets: ${Object.keys(assets).length}/${assetList.length}`, 20, CANVAS_HEIGHT - 48);
                ctx.fillStyle = '#FF0';
                ctx.fillText(`Using delta time for smooth movement`, 20, CANVAS_HEIGHT - 32);
                ctx.fillStyle = '#0FF';
                ctx.fillText(`USE_SIMPLE_BOXES: ${USE_SIMPLE_BOXES}`, 20, CANVAS_HEIGHT - 16);
            }
        }

        function updateMenu(dt) {
            // Bounce the kangaroo
            menuBounceTimer += dt;
            if (menuBounceTimer > 1.2) {
                menuBounceTimer = 0;
                menuKangarooVel = -8; // Jump!
            }

            menuKangarooVel += 25 * dt; // Gravity
            menuKangarooY += menuKangarooVel;

            if (menuKangarooY > 0) {
                menuKangarooY = 0;
                menuKangarooVel = 0;
            }
        }

        function drawStartScreen() {
            // Dark overlay with gradient
            const overlay = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
            overlay.addColorStop(0, 'rgba(15, 23, 42, 0.85)');
            overlay.addColorStop(1, 'rgba(15, 23, 42, 0.6)');
            ctx.fillStyle = overlay;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.textAlign = 'center';
            const centerX = CANVAS_WIDTH / 2;

            // Animated kangaroo (centered, above title)
            if (assets.kangaroo) {
                const frame = Math.floor(menuBounceTimer * 12) % 12;
                const col = frame % 6;
                const row = Math.floor(frame / 6);
                const srcX = col * 128;
                const srcY = row * 128;

                const kY = 140 + menuKangarooY;

                // Squash/stretch based on velocity
                let scaleX = 1, scaleY = 1;
                if (menuKangarooVel < -2) {
                    scaleX = 0.85; scaleY = 1.15;
                } else if (menuKangarooY === 0 && menuKangarooVel === 0) {
                    scaleX = 1.1; scaleY = 0.9;
                }

                const kWidth = 100 * scaleX;
                const kHeight = 100 * scaleY;

                ctx.drawImage(
                    assets.kangaroo,
                    srcX, srcY, 128, 128,
                    centerX - kWidth / 2, kY - kHeight,
                    kWidth, kHeight
                );
            }

            // Title (centered)
            ctx.font = '800 48px Poppins';
            ctx.fillStyle = '#FFF';
            ctx.fillText('KANGAROO', centerX, 220);

            ctx.fillStyle = '#4ADE80';
            ctx.fillText('HOP', centerX, 275);

            // Play button (centered)
            const btnW = 200;
            const btnH = 55;
            const btnX = centerX - btnW / 2;
            const btnY = 320;

            const btnGrad = ctx.createLinearGradient(btnX, btnY, btnX, btnY + btnH);
            btnGrad.addColorStop(0, '#4ADE80');
            btnGrad.addColorStop(1, '#22C55E');
            ctx.fillStyle = btnGrad;
            roundRect(ctx, btnX, btnY, btnW, btnH, 27);
            ctx.fill();

            ctx.fillStyle = '#FFF';
            ctx.font = '700 20px Poppins';
            ctx.fillText('TAP TO PLAY', centerX, btnY + 35);

            // Stats panel (centered)
            const statsW = 180;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            roundRect(ctx, centerX - statsW / 2, 420, statsW, 70, 12);
            ctx.fill();

            ctx.fillStyle = '#FFD700';
            ctx.font = '600 16px Poppins';
            ctx.fillText(`üèÜ Best: ${highScore}`, centerX, 452);

            ctx.fillStyle = '#4ADE80';
            ctx.fillText(`üí∞ Coins: ${totalCoins}`, centerX, 478);

            // Sound toggle button (top right)
            const soundBtnX = CANVAS_WIDTH - 70;
            const soundBtnY = 20;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            roundRect(ctx, soundBtnX, soundBtnY, 50, 50, 12);
            ctx.fill();

            ctx.font = '24px Poppins';
            ctx.fillStyle = '#FFF';
            ctx.fillText(soundEnabled ? 'üîä' : 'üîá', soundBtnX + 25, soundBtnY + 35);

            // Hint (centered)
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.font = '400 13px Poppins';
            ctx.fillText('SPACE or Click to jump ‚Ä¢ Double tap for double jump', centerX, 560);
        }

        function drawGameOver() {
            // Dark overlay
            const overlay = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
            overlay.addColorStop(0, 'rgba(15, 23, 42, 0.95)');
            overlay.addColorStop(1, 'rgba(15, 23, 42, 0.85)');
            ctx.fillStyle = overlay;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.textAlign = 'center';

            // Game Over text
            ctx.font = '800 42px Poppins';
            ctx.fillStyle = '#F87171';
            ctx.fillText('GAME OVER', CANVAS_WIDTH / 2, 140);

            // Score card
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            roundRect(ctx, CANVAS_WIDTH / 2 - 120, 170, 240, 140, 16);
            ctx.fill();

            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = '400 14px Poppins';
            ctx.fillText('SCORE', CANVAS_WIDTH / 2, 200);

            ctx.fillStyle = '#FFF';
            ctx.font = '800 48px Poppins';
            ctx.fillText(Math.floor(score), CANVAS_WIDTH / 2, 255);

            // New high score badge
            if (score >= highScore && score > 0) {
                ctx.fillStyle = '#FBBF24';
                ctx.font = '700 16px Poppins';
                ctx.fillText('üèÜ NEW BEST!', CANVAS_WIDTH / 2, 290);
            }

            // Coins earned
            ctx.fillStyle = '#4ADE80';
            ctx.font = '600 18px Poppins';
            ctx.fillText(`+${coinsCollected} coins`, CANVAS_WIDTH / 2, 360);

            // Retry button
            const btnX = CANVAS_WIDTH / 2 - 90;
            const btnY = 400;
            const btnW = 180;
            const btnH = 50;

            const btnGrad = ctx.createLinearGradient(btnX, btnY, btnX, btnY + btnH);
            btnGrad.addColorStop(0, '#4ADE80');
            btnGrad.addColorStop(1, '#22C55E');
            ctx.fillStyle = btnGrad;
            roundRect(ctx, btnX, btnY, btnW, btnH, 25);
            ctx.fill();

            ctx.fillStyle = '#FFF';
            ctx.font = '700 18px Poppins';
            ctx.fillText('PLAY AGAIN', CANVAS_WIDTH / 2, btnY + 32);

            // Sound toggle button
            const soundBtnX = CANVAS_WIDTH - 70;
            const soundBtnY = 20;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            roundRect(ctx, soundBtnX, soundBtnY, 50, 50, 12);
            ctx.fill();

            ctx.font = '24px Poppins';
            ctx.fillStyle = '#FFF';
            ctx.textAlign = 'center';
            ctx.fillText(soundEnabled ? 'üîä' : 'üîá', soundBtnX + 25, soundBtnY + 35);

            // Hint
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.font = '400 13px Poppins';
            ctx.fillText('Press SPACE or Click', CANVAS_WIDTH / 2, 500);
        }

        // === GAME LOOP ===
        function reset() {
            kangaroo.y = GROUND_Y;
            kangaroo.velocityY = 0;
            kangaroo.onGround = true;
            kangaroo.frame = 0;
            kangaroo.isDead = false;
            kangaroo.deathRotation = 0;
            kangaroo.deathVelocityY = 0;
            kangaroo.scaleX = 1;
            kangaroo.scaleY = 1;
            obstacles = [];
            coins = [];
            particles = [];
            powerups = [];
            // Reset active powerups
            for (const key in activePowerups) {
                activePowerups[key].active = false;
                activePowerups[key].timer = 0;
            }
            gameSpeed = INITIAL_SPEED;
            score = 0;
            coinsCollected = 0;
            gameOver = false;
            showGameOverUI = false;
            gameOverTimer = 0;
            lastObstacleTime = Date.now();
        }

        function update(dt) {
            // Always update these (even during game over)
            updateScreenShake(dt);
            updateParticles(dt);

            // Animate menu when not started
            if (!gameStarted) {
                updateMenu(dt);
                return;
            }

            // Update kangaroo death animation even when game over
            if (gameOver && kangaroo.isDead) {
                kangaroo.update(dt);

                // Delay showing game over UI
                if (!showGameOverUI) {
                    gameOverTimer += dt;
                    if (gameOverTimer >= 1.2) { // 1.2 second delay
                        showGameOverUI = true;
                    }
                }
            }

            if (gameOver) return;

            // Use delta time (dt) for consistent movement
            // Convert gameSpeed from "pixels per frame" to "pixels per second"
            const pixelsPerSecond = gameSpeed * 60; // Assume 60fps base

            kangaroo.update(dt);
            updateObstacles(dt, pixelsPerSecond);
            updateCoins(dt, pixelsPerSecond);
            updatePowerups(dt, pixelsPerSecond);

            // Speed up gradually
            gameSpeed = Math.min(MAX_SPEED, gameSpeed + SPEED_INCREMENT);

            // Score increases over time
            score += 6 * dt; // ~6 points per second

            // Collision check
            if (checkCollisions()) {
                gameOver = true;
                playSound('collision');
                playSound('gameOver');
                // Trigger death animation
                kangaroo.die();
                if (score > highScore) {
                    highScore = Math.floor(score);
                    localStorage.setItem('kangaroo_raw_high', highScore);
                }
                localStorage.setItem('kangaroo_raw_coins', totalCoins);
            }
        }

        function draw() {
            // Clear entire canvas first (important for smooth rendering!)
            ctx.fillStyle = '#4A90D9';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Apply screen shake
            const shake = getShakeOffset();
            ctx.save();
            ctx.translate(shake.x, shake.y);

            drawBackground();
            drawGround();

            if (!gameStarted) {
                kangaroo.draw();
                drawStartScreen();
            } else if (gameOver) {
                drawObstacles();
                drawCoins();
                drawParticles();
                kangaroo.draw();
                drawUI();
                // Only show game over UI after delay
                if (showGameOverUI) {
                    drawGameOver();
                }
            } else {
                drawObstacles();
                drawCoins();
                drawPowerups();
                drawParticles();
                kangaroo.draw();
                drawUI();
            }

            ctx.restore(); // End screen shake
        }

        function gameLoop(currentTime) {
            // Calculate delta time (in seconds)
            deltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;

            // Cap delta time to prevent huge jumps (e.g., when tab inactive)
            deltaTime = Math.min(deltaTime, 0.1);

            // FPS calculation
            frameCount++;
            const now = Date.now();
            if (now - lastFpsUpdate >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = now;
            }

            update(deltaTime);
            draw();
            requestAnimationFrame(gameLoop);
        }

        // === INPUT ===
        function handleInput() {
            if (!gameStarted) {
                gameStarted = true;
                reset();
            } else if (gameOver) {
                // Only allow restart after UI shows
                if (showGameOverUI) {
                    reset();
                }
            } else {
                kangaroo.jump();
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault();
                handleInput();
            }
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check sound button click (top right, 50x50)
            if (!gameStarted || (gameOver && showGameOverUI)) {
                const soundBtnX = CANVAS_WIDTH - 70;
                const soundBtnY = 20;
                if (x >= soundBtnX && x <= soundBtnX + 50 && y >= soundBtnY && y <= soundBtnY + 50) {
                    soundEnabled = !soundEnabled;
                    return;
                }
            }

            handleInput();
        });
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleInput();
        });

        // === START ===
        loadAssets(() => {
            gameLoop();
        });
    </script>
</body>
</html>
