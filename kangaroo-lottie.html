<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kangaroo Hop - Lottie Edition</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            font-family: 'Poppins', sans-serif;
        }
        #gameContainer {
            position: relative;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5), 0 0 40px rgba(79, 172, 254, 0.15);
        }
        canvas {
            display: block;
            border-radius: 16px;
            cursor: pointer;
            transform: translateZ(0);
            will-change: transform;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            font-weight: 600;
        }
        /* Container for Lottie rendering - hidden but must render */
        #lottieContainer {
            position: fixed;
            bottom: 0;
            right: 0;
            opacity: 0.01;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="game" width="800" height="600"></canvas>
        <div id="loading">Loading...</div>
    </div>
    <div id="lottieContainer"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    <script type="module">
        // Import DotLottie for .lottie files
        import { DotLottie } from 'https://cdn.jsdelivr.net/npm/@lottiefiles/dotlottie-web@0.37.0/+esm';

        // ============================================
        // KANGAROO HOP - Lottie Edition
        // Raw Canvas + Lottie Animations
        // ============================================

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d', {
            alpha: false,
            desynchronized: true
        });
        const loadingEl = document.getElementById('loading');
        const lottieContainer = document.getElementById('lottieContainer');

        // === LOTTIE SYSTEM ===
        const lottieAnimations = {};
        const lottieCanvases = {};

        // === SPRITE SYSTEM (for emu, magpie) ===
        const spriteFrames = {};

        // UI Lottie animations
        const LOTTIE_UI = {
            playButton: {
                src: 'assets/lottie/play_button.lottie',
                width: 120,
                height: 120
            },
        };

        // Define your Lottie obstacles here - easy to add more!
        const LOTTIE_OBSTACLES = {
            camel: {
                src: 'assets/lottie/camel.json',
                width: 200,
                height: 180,
                hitboxWidth: 140,
                hitboxHeight: 80,
                hitboxOffsetY: 40,
                groundOffset: 0,
                flipX: true
            },
            crocodile: {
                src: 'assets/lottie/crocodile.json',
                width: 252,           // 10% smaller
                height: 207,          // 10% smaller
                hitboxWidth: 65,
                hitboxHeight: 110,    // Taller
                hitboxOffsetY: 45,
                groundOffset: -30,
                flipX: false,
                speedMultiplier: 1.5,
                animationSpeed: 2.6  // 30% faster than 2.0
            },
            snake: {
                src: 'assets/lottie/snake.json',
                width: 120,           // 20% smaller
                height: 80,           // 20% smaller
                hitboxWidth: 80,
                hitboxHeight: 40,
                hitboxOffsetY: 16,
                groundOffset: 20,    // Move up 20px
                flipX: true
            },
            tree: {
                src: 'assets/lottie/tree.json',
                width: 200,
                height: 280,
                hitboxWidth: 80,      // Wider
                hitboxHeight: 150,    // Shorter
                hitboxOffsetY: 50,    // Move hitbox up
                groundOffset: -20,     // Move down 20px
                flipX: false
            }
        };

        // Background decorations (not obstacles)
        const LOTTIE_DECORATIONS = {
            sun: {
                src: 'assets/lottie/sun.json',
                width: 300,           // 3x bigger
                height: 300,
                x: 550,               // Top right corner
                y: -50                // Partially off screen
            }
        };

        // Sprite-based obstacles (not Lottie)
        const SPRITE_OBSTACLES = {
            emu: {
                prefix: 'ostrich_run_neck_up',
                path: 'assets/characters/emu/brown',
                frameCount: 10,
                frameRate: 20,
                width: 150,
                height: 170,
                hitboxWidth: 60,
                hitboxHeight: 92,
                hitboxOffsetX: 10,  // Move hitbox 10px right
                hitboxOffsetY: 30,
                groundOffset: 0,
                flipX: false,  // Face left (toward kangaroo)
                speedMultiplier: 1.35  // Faster than other obstacles
            },
            magpie: {
                spriteSheet: 'assets/images/magpie_sheet.png',
                frameWidth: 128,
                frameHeight: 128,
                frameCount: 4,
                frameRate: 8,
                width: 100,
                height: 100,
                hitboxWidth: 75,
                hitboxHeight: 42,  // 30% smaller on y-axis
                hitboxOffsetY: 10,
                flipX: true,  // Flip to face left (toward kangaroo)
                isFlying: true,
                spawnYMin: 150,
                spawnYMax: 250,
                swoopSpeed: 400,
                climbSpeed: 300,
                swoopChance: 0.5
            }
        };

        async function loadLottieAnimation(name, config) {
            return new Promise((resolve, reject) => {
                const isJson = config.src.endsWith('.json');

                // Create container div for lottie-web, or canvas for DotLottie
                if (isJson) {
                    // Use lottie-web for .json files (renders to SVG, we'll capture to canvas)
                    const container = document.createElement('div');
                    container.id = `lottie-${name}`;
                    container.style.width = config.width + 'px';
                    container.style.height = config.height + 'px';
                    lottieContainer.appendChild(container);

                    try {
                        const anim = lottie.loadAnimation({
                            container: container,
                            renderer: 'canvas',  // Use canvas renderer for better performance
                            loop: true,
                            autoplay: true,
                            path: config.src,
                            rendererSettings: {
                                preserveAspectRatio: 'xMidYMid slice'
                            }
                        });

                        anim.addEventListener('DOMLoaded', () => {
                            // Get the canvas that lottie-web created
                            const canvas = container.querySelector('canvas');
                            if (canvas) {
                                lottieAnimations[name] = anim;
                                lottieCanvases[name] = canvas;
                                console.log(`✓ Loaded JSON lottie: ${name}`);
                                resolve(anim);
                            } else {
                                reject(new Error('No canvas created'));
                            }
                        });

                        anim.addEventListener('error', (err) => {
                            console.error(`✗ Failed to load Lottie: ${name}`, err);
                            reject(err);
                        });
                    } catch (err) {
                        console.error(`Error creating lottie-web for ${name}:`, err);
                        reject(err);
                    }
                } else {
                    // Use DotLottie for .lottie files
                    const lottieCanvas = document.createElement('canvas');
                    lottieCanvas.id = `lottie-${name}`;
                    lottieCanvas.width = config.width;
                    lottieCanvas.height = config.height;
                    lottieContainer.appendChild(lottieCanvas);

                    try {
                        const dotLottie = new DotLottie({
                            canvas: lottieCanvas,
                            src: config.src,
                            loop: true,
                            autoplay: true,
                            speed: config.animationSpeed || 1.0
                        });

                        dotLottie.addEventListener('load', () => {
                            lottieAnimations[name] = dotLottie;
                            lottieCanvases[name] = lottieCanvas;
                            console.log(`✓ Loaded DotLottie: ${name}`);
                            resolve(dotLottie);
                        });

                        dotLottie.addEventListener('loadError', (error) => {
                            console.error(`✗ Failed to load Lottie: ${name}`, error);
                            reject(error);
                        });

                        setTimeout(() => {
                            if (!lottieAnimations[name] && dotLottie.isLoaded) {
                                lottieAnimations[name] = dotLottie;
                                lottieCanvases[name] = lottieCanvas;
                                resolve(dotLottie);
                            }
                        }, 3000);
                    } catch (err) {
                        console.error(`Error creating DotLottie for ${name}:`, err);
                        reject(err);
                    }
                }
            });
        }

        async function loadAllLotties() {
            // Load obstacle lotties
            const obstaclePromises = Object.entries(LOTTIE_OBSTACLES).map(([name, config]) =>
                loadLottieAnimation(name, config).catch(() => null)
            );
            // Load UI lotties
            const uiPromises = Object.entries(LOTTIE_UI).map(([name, config]) =>
                loadLottieAnimation(name, config).catch(() => null)
            );
            // Load decoration lotties
            const decorationPromises = Object.entries(LOTTIE_DECORATIONS).map(([name, config]) =>
                loadLottieAnimation(name, config).catch(() => null)
            );
            await Promise.all([...obstaclePromises, ...uiPromises, ...decorationPromises]);
        }

        async function loadSpriteFrames() {
            // Load emu frames (individual PNGs)
            const emuConfig = SPRITE_OBSTACLES.emu;
            spriteFrames.emu = [];
            for (let i = 0; i < emuConfig.frameCount; i++) {
                const img = new Image();
                const frameNum = String(i).padStart(3, '0');
                img.src = `${emuConfig.path}/${emuConfig.prefix}_${frameNum}.png`;
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = () => {
                        console.error(`Failed to load emu frame ${i}`);
                        resolve();
                    };
                });
                spriteFrames.emu.push(img);
            }
            console.log(`✓ Loaded emu sprite: ${spriteFrames.emu.length} frames`);

            // Load magpie sprite sheet and extract frames
            const magpieConfig = SPRITE_OBSTACLES.magpie;
            const sheet = new Image();
            sheet.src = magpieConfig.spriteSheet;
            await new Promise((resolve, reject) => {
                sheet.onload = resolve;
                sheet.onerror = () => {
                    console.error('Failed to load magpie sprite sheet');
                    resolve();
                };
            });

            // Extract frames from sprite sheet into canvases
            spriteFrames.magpie = [];
            for (let i = 0; i < magpieConfig.frameCount; i++) {
                const frameCanvas = document.createElement('canvas');
                frameCanvas.width = magpieConfig.frameWidth;
                frameCanvas.height = magpieConfig.frameHeight;
                const frameCtx = frameCanvas.getContext('2d');
                frameCtx.drawImage(sheet,
                    i * magpieConfig.frameWidth, 0,
                    magpieConfig.frameWidth, magpieConfig.frameHeight,
                    0, 0, magpieConfig.frameWidth, magpieConfig.frameHeight
                );
                spriteFrames.magpie.push(frameCanvas);
            }
            console.log(`✓ Loaded magpie sprite: ${spriteFrames.magpie.length} frames`);
        }

        // === AUDIO ===
        const sounds = {
            jump: new Audio('assets/audio/sfx/jump.mp3'),
            doubleJump: new Audio('assets/audio/sfx/double_jump.mp3'),
            land: new Audio('assets/audio/sfx/land.mp3'),
            coin: new Audio('assets/audio/sfx/coin_collect.mp3'),
            collision: new Audio('assets/audio/sfx/collision.mp3'),
            gameOver: new Audio('assets/audio/sfx/game_over.mp3'),
            buttonClick: new Audio('assets/audio/sfx/button_click.mp3'),
            // Music
            musicMenu: new Audio('assets/audio/music/menu_music.mp3'),
            musicGame: new Audio('assets/audio/music/outback_music.mp3')
        };

        sounds.jump.volume = 0.7;
        sounds.doubleJump.volume = 0.8;
        sounds.land.volume = 0.6;
        sounds.coin.volume = 0.9;
        sounds.collision.volume = 0.8;
        sounds.gameOver.volume = 1.0;
        sounds.buttonClick.volume = 0.6;
        sounds.musicMenu.volume = 0.3;
        sounds.musicGame.volume = 0.4;
        sounds.musicMenu.loop = true;
        sounds.musicGame.loop = true;

        let currentMusic = null;

        function playMusic(name) {
            if (!soundEnabled) return;
            // Stop current music
            if (currentMusic) {
                currentMusic.pause();
                currentMusic.currentTime = 0;
            }
            const music = sounds[name];
            if (music) {
                currentMusic = music;
                music.play().catch(() => {});
            }
        }

        function stopMusic() {
            if (currentMusic) {
                currentMusic.pause();
                currentMusic.currentTime = 0;
                currentMusic = null;
            }
        }

        function playSound(name) {
            if (!soundEnabled) return;
            const sound = sounds[name];
            if (sound) {
                sound.currentTime = 0;
                sound.play().catch(() => {});
            }
        }

        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        // === CONSTANTS ===
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const GROUND_Y = 500;
        const GRAVITY = 1.0;
        const JUMP_FORCE = -22;
        const INITIAL_SPEED = 7;
        const MAX_SPEED = 15;
        const SPEED_INCREMENT = 0.002;
        const DEBUG = false;  // Set true to see hitboxes (currently only emu/magpie)
        const JUMP_DEBUG = false;  // Show 4 kangaroos with different jump animations
        const SPAWN_DEBUG = false;  // Set true to only spawn emu and magpie for testing
        // =====================================================
        // CROC GAP SETTINGS (tested at starting speed 7)
        // =====================================================
        // The crocodile moves 1.5x faster than other obstacles, so spacing matters!
        //
        // VALID RANGES:
        // - 350-650px: "Double jump zone" - jump over both without landing
        // - 850px+:    "Landing zone" - land between obstacles, then jump croc
        //
        // FORBIDDEN:
        // - 650-850px: Too tricky - not enough time to land OR double jump
        //
        // The spawn logic randomly picks from valid ranges only.
        // =====================================================
        const CROC_GAP_MIN_DOUBLE = 350;   // Minimum for double jump
        const CROC_GAP_MAX_DOUBLE = 650;   // Maximum for double jump
        const CROC_GAP_MIN_LANDING = 850;  // Minimum for landing between
        const CROC_GAP_MAX_LANDING = 1000; // Maximum for landing (keeps it challenging)

        // For debug testing - set to specific value or null to use random
        const CROC_GAP_PIXELS = null;  // null = use random valid range

        // Gap from croc back to next camel (croc → camel)
        const CAMEL_AFTER_CROC_GAP = 1000;  // Fixed for testing

        // === PARTICLES ===
        let particles = [];

        function spawnDustParticles(x, y) {
            const count = 8 + Math.floor(Math.random() * 5);
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 40,
                    y: y,
                    vx: (Math.random() - 0.5) * 150,
                    vy: -Math.random() * 80 - 20,
                    size: 4 + Math.random() * 8,
                    life: 0.4 + Math.random() * 0.3,
                    maxLife: 0.4 + Math.random() * 0.3,
                    color: Math.random() > 0.5 ? '#C4A574' : '#A68B5B',
                    type: 'dust'
                });
            }
        }

        function spawnCoinSparkles(x, y) {
            const count = 12 + Math.floor(Math.random() * 6);
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
                const speed = 100 + Math.random() * 150;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 3 + Math.random() * 5,
                    life: 0.3 + Math.random() * 0.3,
                    maxLife: 0.3 + Math.random() * 0.3,
                    color: Math.random() > 0.5 ? '#FFD700' : '#FFF176',
                    type: 'sparkle'
                });
            }
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;

                if (p.type === 'dust') {
                    p.vy += 200 * dt;
                } else if (p.type === 'sparkle') {
                    p.vx *= 0.95;
                    p.vy *= 0.95;
                }

                p.life -= dt;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                const alpha = p.life / p.maxLife;

                if (p.type === 'sparkle') {
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(Math.round(p.x), Math.round(p.y), p.size * alpha * 1.5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(Math.round(p.x), Math.round(p.y), p.size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.globalAlpha = alpha * 0.7;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(Math.round(p.x), Math.round(p.y), p.size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            ctx.globalAlpha = 1;
        }

        // === ASSETS ===
        const assets = {};

        // Kangaroo animation frames (from Phaser version's character system)
        const KANGAROO_ANIMATIONS = {
            moving: { prefix: 'red_kangaroo_no_joey_moving', frameCount: 16, frameRate: 20 },
            jump: { prefix: 'red_kangaroo_no_joey_jump_from_idle', frameStart: 0, frameEnd: 6, frameRate: 20, hold: true },  // Frames 0-6, hold on last
            die: { prefix: 'red_kangaroo_no_joey_die', frameCount: 5, frameRate: 10 },
            idle: { prefix: 'red_kangaroo_no_joey_idle', frameCount: 20, frameRate: 12 }
        };

        // Store animation frames
        const kangarooFrames = {
            moving: [],
            jump: [],
            die: [],
            idle: []
        };

        const assetList = [
            { name: 'coin', src: 'assets/images/coin/coin-64x64.png' }
        ];

        function loadAssets(callback) {
            let loaded = 0;
            let total = assetList.length;

            // Calculate total frames to load
            Object.values(KANGAROO_ANIMATIONS).forEach(anim => {
                if (anim.frameStart !== undefined) {
                    total += (anim.frameEnd - anim.frameStart + 1);
                } else {
                    total += anim.frameCount;
                }
            });

            if (total === 0) {
                callback();
                return;
            }

            const checkComplete = () => {
                loadingEl.textContent = `Loading... ${Math.floor(loaded / total * 100)}%`;
                if (loaded === total) callback();
            };

            // Load regular assets
            assetList.forEach(asset => {
                const img = new Image();
                img.onload = () => {
                    assets[asset.name] = img;
                    loaded++;
                    checkComplete();
                };
                img.onerror = () => {
                    console.error(`Failed to load: ${asset.name}`);
                    loaded++;
                    checkComplete();
                };
                img.src = asset.src;
            });

            // Load kangaroo animation frames
            Object.entries(KANGAROO_ANIMATIONS).forEach(([animName, config]) => {
                const start = config.frameStart !== undefined ? config.frameStart : 0;
                const end = config.frameEnd !== undefined ? config.frameEnd : config.frameCount - 1;

                let localIndex = 0;
                for (let i = start; i <= end; i++) {
                    const frameNum = String(i).padStart(3, '0');
                    const img = new Image();
                    const idx = localIndex;  // Capture for closure
                    img.onload = () => {
                        kangarooFrames[animName][idx] = img;
                        loaded++;
                        checkComplete();
                    };
                    img.onerror = () => {
                        console.error(`Failed to load kangaroo frame: ${animName}_${frameNum}`);
                        loaded++;
                        checkComplete();
                    };
                    img.src = `assets/characters/kangaroo/brown/${config.prefix}_${frameNum}.png`;
                    localIndex++;
                }
            });
        }

        // === GAME STATE ===
        let gameSpeed = INITIAL_SPEED;
        let score = 0;
        let highScore = parseInt(localStorage.getItem('kangaroo_lottie_high')) || 0;
        let coinsCollected = 0;
        let totalCoins = parseInt(localStorage.getItem('kangaroo_lottie_coins')) || 0;
        let gameOver = false;
        let showGameOverUI = false;
        let gameOverTimer = 0;
        let gameStarted = false;
        let soundEnabled = true;
        let deltaTime = 0;
        let lastFrameTime = performance.now();

        // Menu animation
        let menuKangarooY = 0;
        let menuKangarooVel = 0;
        let menuBounceTimer = 0;

        // === KANGAROO ===
        const DOUBLE_JUMP_FORCE = -17;

        const kangaroo = {
            x: 100,
            y: GROUND_Y,
            width: 154,           // Match Phaser version display size
            height: 178,
            velocityY: 0,
            onGround: true,
            wasOnGround: true,
            canDoubleJump: false,

            // Animation state
            currentAnim: 'moving',
            frame: 0,
            frameTimer: 0,

            // Squash & stretch
            scaleX: 1,
            scaleY: 1,
            squashTime: 0,

            // Death state
            isDead: false,
            deathFrame: 0,
            deathAnimStarted: false,
            landSoundPlayed: false,

            update(dt) {
                // Update animation frame
                this.frameTimer += dt;
                const anim = KANGAROO_ANIMATIONS[this.currentAnim];

                // Scale running animation speed with game speed
                let effectiveFrameRate = anim.frameRate;
                if (this.currentAnim === 'moving') {
                    const speedScale = gameSpeed / INITIAL_SPEED;
                    effectiveFrameRate = anim.frameRate * speedScale;
                }
                const frameDelay = 1 / effectiveFrameRate;

                if (this.frameTimer >= frameDelay) {
                    this.frameTimer = 0;

                    if (this.isDead && this.deathAnimStarted) {
                        // Death animation plays once
                        if (this.deathFrame < KANGAROO_ANIMATIONS.die.frameCount - 1) {
                            this.deathFrame++;
                        }
                    } else if (!this.isDead) {
                        const maxFrames = kangarooFrames[this.currentAnim].length;
                        // Check if animation should hold on last frame
                        if (anim.hold && this.frame >= maxFrames - 1) {
                            // Stay on last frame
                            this.frame = maxFrames - 1;
                        } else {
                            // Loop animation
                            this.frame = (this.frame + 1) % maxFrames;
                        }
                    }
                }

                // When dead, keep falling until hitting ground
                if (this.isDead) {
                    if (!this.onGround) {
                        // Keep falling
                        const gravityPerSecond = GRAVITY * 60;
                        this.velocityY += gravityPerSecond * dt;
                        this.y += this.velocityY * dt * 60;

                        if (this.y >= GROUND_Y) {
                            this.y = GROUND_Y;
                            this.velocityY = 0;
                            this.onGround = true;
                            // Now start death animation
                            this.deathAnimStarted = true;
                            this.currentAnim = 'die';
                            this.deathFrame = 0;
                            this.frame = 0;
                            spawnDustParticles(this.x, GROUND_Y);
                        }
                    }
                    return;
                }

                this.wasOnGround = this.onGround;
                const gravityPerSecond = GRAVITY * 60;
                this.velocityY += gravityPerSecond * dt;
                this.y += this.velocityY * dt * 60;

                // Play land sound slightly before hitting ground (when close and descending)
                if (!this.onGround && this.velocityY > 0 && this.y > GROUND_Y - 30 && !this.landSoundPlayed) {
                    playSound('land');
                    this.landSoundPlayed = true;
                }

                if (this.y >= GROUND_Y) {
                    this.y = GROUND_Y;
                    this.velocityY = 0;
                    this.onGround = true;
                    this.canDoubleJump = false;
                    this.landSoundPlayed = false;  // Reset for next jump

                    // Switch to moving animation when landing
                    if (!this.wasOnGround) {
                        this.currentAnim = 'moving';
                        this.frame = 0;
                        this.squashTime = 0.15;
                        this.scaleX = 1.3;
                        this.scaleY = 0.7;
                        // Spawn dust particles!
                        spawnDustParticles(this.x, GROUND_Y);
                    }
                } else {
                    // In air - use jump animation
                    if (this.currentAnim !== 'jump') {
                        this.currentAnim = 'jump';
                        this.frame = 0;
                    }
                }

                // Animate squash back to normal
                if (this.squashTime > 0) {
                    this.squashTime -= dt;
                    this.scaleX += (1 - this.scaleX) * 10 * dt;
                    this.scaleY += (1 - this.scaleY) * 10 * dt;
                } else {
                    this.scaleX = 1;
                    this.scaleY = 1;
                }
            },

            die() {
                this.isDead = true;
                // If already on ground, start death anim immediately
                if (this.onGround) {
                    this.deathAnimStarted = true;
                    this.currentAnim = 'die';
                    this.deathFrame = 0;
                    this.frame = 0;
                } else {
                    this.deathAnimStarted = false;  // Wait until on ground
                }
            },

            jump() {
                if (this.isDead) return;
                if (this.onGround) {
                    this.velocityY = JUMP_FORCE;
                    this.onGround = false;
                    this.canDoubleJump = true;
                    this.landSoundPlayed = false;  // Reset for landing
                    this.currentAnim = 'jump';
                    this.frame = 0;
                    playSound('jump');
                    this.scaleX = 0.8;
                    this.scaleY = 1.2;
                    this.squashTime = 0.1;
                } else if (this.canDoubleJump) {
                    this.velocityY = DOUBLE_JUMP_FORCE;
                    this.canDoubleJump = false;
                    this.frame = 0;
                    playSound('doubleJump');
                    this.scaleX = 0.8;
                    this.scaleY = 1.2;
                    this.squashTime = 0.1;
                }
            },

            draw() {
                const scaledWidth = this.width * this.scaleX;
                const scaledHeight = this.height * this.scaleY;
                const drawX = Math.round(this.x);
                const drawY = Math.round(this.y);

                ctx.save();

                // Get the right frame
                let frameImg;
                if (this.isDead) {
                    frameImg = kangarooFrames.die[this.deathFrame];
                } else {
                    frameImg = kangarooFrames[this.currentAnim][this.frame];
                }

                if (frameImg) {
                    // Flip horizontally - kangaroo sprites face left, we need right
                    // Offset to align feet with ground (sprites have padding)
                    const groundAdjust = 30;
                    ctx.translate(drawX, drawY + groundAdjust);
                    ctx.scale(-1, 1);  // Flip horizontally
                    ctx.drawImage(
                        frameImg,
                        -scaledWidth / 2,
                        -scaledHeight,
                        scaledWidth,
                        scaledHeight
                    );
                }

                ctx.restore();

                if (DEBUG) {
                    const bounds = this.getBounds();
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);
                }
            },

            getBounds() {
                // Hitbox aligned with visual sprite (+30 ground adjust, +20 forward)
                return {
                    x: this.x - 36 + 20,  // Moved 20px forward
                    y: this.y - 120 + 30,
                    width: 72,
                    height: 75
                };
            }
        };

        // === DEBUG: 4 KANGAROOS WITH DIFFERENT JUMP ANIMATIONS ===
        const debugJumpConfigs = [
            { label: '0-6', start: 0, end: 6 },
            { label: '0-8', start: 0, end: 8 },
            { label: '2-6', start: 2, end: 6 },
            { label: '2-8', start: 2, end: 8 }
        ];

        const debugKangaroos = debugJumpConfigs.map((config, i) => ({
            x: 100 + i * 180,
            y: GROUND_Y,
            velocityY: 0,
            onGround: true,
            frame: 0,
            frameTimer: 0,
            jumpTimer: 0,
            jumpStart: config.start,
            jumpEnd: config.end,
            label: config.label,
            currentAnim: 'moving',
            width: 100,
            height: 116
        }));

        function updateDebugKangaroos(dt) {
            debugKangaroos.forEach(k => {
                // Auto jump every 2 seconds
                k.jumpTimer += dt;
                if (k.jumpTimer > 2 && k.onGround) {
                    k.velocityY = JUMP_FORCE;
                    k.onGround = false;
                    k.currentAnim = 'jump';
                    k.frame = k.jumpStart;
                    k.jumpTimer = 0;
                }

                // Physics
                k.velocityY += GRAVITY * 60 * dt;
                k.y += k.velocityY * dt * 60;

                if (k.y >= GROUND_Y) {
                    k.y = GROUND_Y;
                    k.velocityY = 0;
                    k.onGround = true;
                    k.currentAnim = 'moving';
                    k.frame = 0;
                }

                // Animate
                k.frameTimer += dt;
                const frameDelay = 1 / 20;
                if (k.frameTimer >= frameDelay) {
                    k.frameTimer = 0;
                    if (k.currentAnim === 'jump') {
                        if (k.frame < k.jumpEnd) {
                            k.frame++;
                        }
                        // Hold on last frame
                    } else {
                        k.frame = (k.frame + 1) % kangarooFrames.moving.length;
                    }
                }
            });
        }

        function drawDebugKangaroos() {
            debugKangaroos.forEach(k => {
                const frameImg = k.currentAnim === 'jump'
                    ? kangarooFrames.jump[k.frame]
                    : kangarooFrames.moving[k.frame];

                if (frameImg) {
                    ctx.save();
                    ctx.translate(Math.round(k.x), Math.round(k.y) + 30);
                    ctx.scale(-1, 1);
                    ctx.drawImage(frameImg, -k.width / 2, -k.height, k.width, k.height);
                    ctx.restore();
                }

                // Label
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 16px Poppins';
                ctx.textAlign = 'center';
                ctx.fillText(k.label, k.x, GROUND_Y + 30);
            });
        }

        // === OBSTACLES (Now with Lottie support!) ===
        let obstacles = [];
        let lastObstacleTime = 0;
        let obstacleInterval = 1500 + Math.random() * 1500;  // 1500-3000ms base spacing

        let debugSpawnIndex = 0;  // Alternates: 0=camel, 1=croc

        function spawnEmu() {
            const config = SPRITE_OBSTACLES.emu;
            obstacles.push({
                x: CANVAS_WIDTH + 50,
                y: GROUND_Y - config.groundOffset,
                width: config.width,
                height: config.height,
                hitboxWidth: config.hitboxWidth,
                hitboxHeight: config.hitboxHeight,
                hitboxOffsetX: config.hitboxOffsetX || 0,
                hitboxOffsetY: config.hitboxOffsetY || 0,
                speedMultiplier: config.speedMultiplier || 1.0,
                isSprite: true,
                spriteType: 'emu',
                frame: 0,
                frameTimer: 0
            });
        }

        function spawnMagpie() {
            const config = SPRITE_OBSTACLES.magpie;
            const spawnY = config.spawnYMin + Math.random() * (config.spawnYMax - config.spawnYMin);
            obstacles.push({
                x: CANVAS_WIDTH + 50,
                y: spawnY,
                width: config.width,
                height: config.height,
                hitboxWidth: config.hitboxWidth,
                hitboxHeight: config.hitboxHeight,
                hitboxOffsetY: config.hitboxOffsetY || 0,
                speedMultiplier: 1.0,
                isSprite: true,
                isFlying: true,
                spriteType: 'magpie',
                frame: 0,
                frameTimer: 0,
                baseY: spawnY,
                swoopStarted: false,
                isClimbingBack: false,
                willSwoop: Math.random() < config.swoopChance,
                rotation: 0
            });
        }

        function spawnObstacle() {
            if (SPAWN_DEBUG) {
                // Debug mode: only magpie for testing at max speed
                const pattern = ['magpie'];
                const name = pattern[debugSpawnIndex % pattern.length];

                if (name === 'emu') {
                    spawnEmu();
                } else if (name === 'magpie') {
                    spawnMagpie();
                } else {
                    const config = LOTTIE_OBSTACLES[name];
                    if (config && lottieAnimations[name]) {
                        obstacles.push({
                            x: CANVAS_WIDTH + 50,
                            y: GROUND_Y - config.groundOffset,
                            width: config.width,
                            height: config.height,
                            hitboxWidth: config.hitboxWidth,
                            hitboxHeight: config.hitboxHeight,
                            hitboxOffsetY: config.hitboxOffsetY || 0,
                            speedMultiplier: config.speedMultiplier || 1.0,
                            lottie: name,
                            isLottie: true
                        });
                    }
                }
                debugSpawnIndex++;
                return;
            }

            // Normal mode: 15% chance for magpie
            if (Math.random() < 0.15) {
                spawnMagpie();
                return;
            }

            // Otherwise spawn ground obstacle (Lottie or emu)
            const allGroundObstacles = [...Object.keys(LOTTIE_OBSTACLES), 'emu'];
            const name = allGroundObstacles[Math.floor(Math.random() * allGroundObstacles.length)];

            if (name === 'emu') {
                spawnEmu();
            } else {
                const config = LOTTIE_OBSTACLES[name];
                obstacles.push({
                    x: CANVAS_WIDTH + 50,
                    y: GROUND_Y - config.groundOffset,
                    width: config.width,
                    height: config.height,
                    hitboxWidth: config.hitboxWidth,
                    hitboxHeight: config.hitboxHeight,
                    hitboxOffsetY: config.hitboxOffsetY || 0,
                    speedMultiplier: config.speedMultiplier || 1.0,
                    lottie: name,
                    isLottie: true
                });
            }
        }

        function updateMagpieAI(magpie, dt) {
            const config = SPRITE_OBSTACLES.magpie;
            const SWOOP_TARGET_Y = GROUND_Y - 50;

            // Scale swoop/climb speed with game speed (faster game = faster swoop)
            const BASE_SPEED = 7;  // Base speed for scaling (don't use INITIAL_SPEED which may change for testing)
            const speedScale = gameSpeed / BASE_SPEED;
            const currentSwoopSpeed = config.swoopSpeed * speedScale;
            const currentClimbSpeed = config.climbSpeed * speedScale;

            // Check if should start swooping (based on distance to kangaroo)
            const distToKangaroo = magpie.x - kangaroo.x;
            if (!magpie.swoopStarted && magpie.willSwoop && distToKangaroo < 450) {
                magpie.swoopStarted = true;
            }

            // Swooping phase - dive down
            if (magpie.swoopStarted && !magpie.isClimbingBack) {
                if (magpie.y < SWOOP_TARGET_Y) {
                    magpie.y += currentSwoopSpeed * dt;
                    magpie.rotation = -Math.PI / 4;  // -45 degrees (diving)
                } else {
                    magpie.rotation = 0;
                    // Start climbing when past the kangaroo
                    if (magpie.x < kangaroo.x + 80) {
                        magpie.isClimbingBack = true;
                    }
                }
            }

            // Climbing phase - return to original height
            if (magpie.isClimbingBack) {
                if (magpie.y > magpie.baseY) {
                    magpie.y -= currentClimbSpeed * dt;
                    magpie.rotation = Math.PI / 6;  // +30 degrees (climbing)
                } else {
                    magpie.y = magpie.baseY;
                    magpie.rotation = 0;
                }
            }
        }

        function updateObstacles(dt, pixelsPerSecond) {
            const now = Date.now();

            if (now - lastObstacleTime > obstacleInterval) {
                spawnObstacle();
                lastObstacleTime = now;
                // Tighter clusters at higher speeds (jumpable together)
                if (gameSpeed > 10) {
                    obstacleInterval = 300 + Math.random() * 300;  // 300-600ms tight clusters
                } else {
                    obstacleInterval = 1500 + Math.random() * 1500;  // 1500-3000ms base spacing
                }
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                const speedMult = obs.speedMultiplier || 1.0;
                obs.x -= pixelsPerSecond * speedMult * dt;

                // Animate sprite frames
                if (obs.isSprite) {
                    const config = SPRITE_OBSTACLES[obs.spriteType];
                    obs.frameTimer += dt;
                    const frameDelay = 1 / config.frameRate;
                    if (obs.frameTimer >= frameDelay) {
                        obs.frameTimer = 0;
                        obs.frame = (obs.frame + 1) % config.frameCount;
                    }
                }

                // Magpie swooping AI
                if (obs.isFlying && obs.spriteType === 'magpie') {
                    updateMagpieAI(obs, dt);
                }

                if (obs.x < -150) {
                    obstacles.splice(i, 1);
                    score += 10;
                }
            }
        }

        function drawObstacles() {
            obstacles.forEach(obs => {
                // Draw sprite-based obstacles (emu, magpie)
                if (obs.isSprite && spriteFrames[obs.spriteType]) {
                    const config = SPRITE_OBSTACLES[obs.spriteType];
                    const frameImg = spriteFrames[obs.spriteType][obs.frame];

                    if (frameImg) {
                        ctx.save();

                        // Position at obstacle center
                        ctx.translate(Math.round(obs.x), Math.round(obs.y));

                        // Apply rotation (for magpie swooping)
                        if (obs.rotation) {
                            ctx.rotate(obs.rotation);
                        }

                        // Flip horizontally if needed
                        if (config.flipX) {
                            ctx.scale(-1, 1);
                        }

                        // Draw sprite - flying obstacles use center anchor, ground use bottom
                        const groundAdjust = obs.isFlying ? -obs.height / 2 : 40 - obs.height;
                        ctx.drawImage(frameImg,
                            -obs.width / 2,
                            groundAdjust,
                            obs.width,
                            obs.height
                        );

                        ctx.restore();
                    }
                }
                // Draw Lottie-based obstacles
                else if (obs.isLottie && lottieCanvases[obs.lottie]) {
                    const offCanvas = lottieCanvases[obs.lottie];
                    const config = LOTTIE_OBSTACLES[obs.lottie];

                    ctx.save();

                    // Adjust to align with ground (Lottie may have padding)
                    const groundAdjust = 40;

                    // Flip horizontally if needed (to face left)
                    if (config && config.flipX) {
                        ctx.translate(obs.x, 0);
                        ctx.scale(-1, 1);
                        ctx.drawImage(
                            offCanvas,
                            0, 0, offCanvas.width, offCanvas.height,
                            -obs.width / 2,
                            Math.round(obs.y - obs.height + groundAdjust),
                            obs.width,
                            obs.height
                        );
                    } else {
                        ctx.drawImage(
                            offCanvas,
                            0, 0, offCanvas.width, offCanvas.height,
                            Math.round(obs.x - obs.width / 2),
                            Math.round(obs.y - obs.height + groundAdjust),
                            obs.width,
                            obs.height
                        );
                    }

                    ctx.restore();
                }

                // Debug: draw hitbox (only for sprite obstacles when DEBUG is on)
                if (DEBUG && obs.isSprite) {
                    const hbWidth = obs.hitboxWidth || obs.width - 20;
                    const hbHeight = obs.hitboxHeight || obs.height - 20;
                    const hbOffsetX = obs.hitboxOffsetX || 0;
                    const hbOffsetY = obs.hitboxOffsetY || 0;

                    // Flying obstacles use center-based hitbox
                    let hbX, hbY;
                    if (obs.isFlying) {
                        hbX = obs.x - hbWidth / 2 + hbOffsetX;
                        hbY = obs.y - hbHeight / 2;
                    } else {
                        const groundAdjust = 40;
                        hbX = obs.x - hbWidth / 2 + hbOffsetX;
                        hbY = obs.y - hbHeight - hbOffsetY + groundAdjust;
                    }

                    ctx.strokeStyle = obs.isFlying ? '#FF00FF' : '#00FF00';  // Magenta for magpie, green for emu
                    ctx.lineWidth = 2;
                    ctx.strokeRect(Math.round(hbX), Math.round(hbY), hbWidth, hbHeight);
                }
            });
        }

        // === COINS ===
        let coins = [];

        function spawnCoin(x) {
            coins.push({
                x: x || CANVAS_WIDTH + Math.random() * 200,
                y: GROUND_Y - 50 - Math.random() * 80,
                size: 40,
                frame: 0,
                frameTimer: 0,
                collected: false
            });
        }

        function updateCoins(dt, pixelsPerSecond) {
            if (Math.random() < 0.6 * dt) spawnCoin();

            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                coin.x -= pixelsPerSecond * dt;
                coin.frameTimer += dt;
                if (coin.frameTimer >= 0.04) {
                    coin.frameTimer = 0;
                    coin.frame = (coin.frame + 1) % 25;
                }

                if (!coin.collected) {
                    const k = kangaroo.getBounds();
                    if (k.x < coin.x + coin.size && k.x + k.width > coin.x - coin.size &&
                        k.y < coin.y + coin.size && k.y + k.height > coin.y - coin.size) {
                        coin.collected = true;
                        coinsCollected++;
                        totalCoins++;
                        score += 5;
                        playSound('coin');
                        spawnCoinSparkles(coin.x, coin.y);
                    }
                }

                if (coin.x < -50 || coin.collected) {
                    coins.splice(i, 1);
                }
            }
        }

        function drawCoins() {
            coins.forEach(coin => {
                if (assets.coin) {
                    ctx.drawImage(
                        assets.coin,
                        coin.frame * 64, 0, 64, 64,
                        Math.round(coin.x - coin.size / 2),
                        Math.round(coin.y - coin.size / 2),
                        coin.size, coin.size
                    );
                } else {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(coin.x, coin.y, coin.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        // === COLLISION ===
        function checkCollisions() {
            const k = kangaroo.getBounds();

            for (const obs of obstacles) {
                const hbWidth = obs.hitboxWidth || obs.width - 20;
                const hbHeight = obs.hitboxHeight || obs.height - 20;
                const hbOffsetX = obs.hitboxOffsetX || 0;
                const hbOffsetY = obs.hitboxOffsetY || 0;

                // Flying obstacles use center-based hitbox, ground obstacles use bottom-anchor
                let o;
                if (obs.isFlying) {
                    o = {
                        x: obs.x - hbWidth / 2 + hbOffsetX,
                        y: obs.y - hbHeight / 2,
                        width: hbWidth,
                        height: hbHeight
                    };
                } else {
                    const groundAdjust = 40;  // Match visual offset
                    o = {
                        x: obs.x - hbWidth / 2 + hbOffsetX,
                        y: obs.y - hbHeight - hbOffsetY + groundAdjust,
                        width: hbWidth,
                        height: hbHeight
                    };
                }

                if (k.x < o.x + o.width && k.x + k.width > o.x &&
                    k.y < o.y + o.height && k.y + k.height > o.y) {
                    return true;
                }
            }
            return false;
        }

        // === BACKGROUND ===
        function drawBackground() {
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, CANVAS_WIDTH, GROUND_Y);
        }

        // === DECORATIONS (background lotties like sun) ===
        function drawDecorations() {
            Object.entries(LOTTIE_DECORATIONS).forEach(([name, config]) => {
                if (lottieCanvases[name]) {
                    const offCanvas = lottieCanvases[name];
                    ctx.drawImage(
                        offCanvas,
                        0, 0, offCanvas.width, offCanvas.height,
                        config.x, config.y, config.width, config.height
                    );
                }
            });
        }

        function drawGround() {
            // Simple brown ground
            ctx.fillStyle = '#8B7355';
            ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, CANVAS_HEIGHT - GROUND_Y);

            // Ground line
            ctx.fillStyle = '#6B5344';
            ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, 4);
        }

        // === UI ===
        function drawUI() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            roundRect(ctx, CANVAS_WIDTH - 160, 10, 150, 70, 12);
            ctx.fill();

            ctx.fillStyle = '#FFF';
            ctx.font = '600 28px Poppins';
            ctx.textAlign = 'right';
            ctx.fillText(Math.floor(score), CANVAS_WIDTH - 25, 45);
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.font = '400 14px Poppins';
            ctx.fillText(`BEST: ${Math.floor(highScore)}`, CANVAS_WIDTH - 25, 68);

            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            roundRect(ctx, 10, 10, 130, 70, 12);
            ctx.fill();

            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(40, 35, 15, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#FFF';
            ctx.font = '700 22px Poppins';
            ctx.textAlign = 'left';
            ctx.fillText(totalCoins, 65, 42);
            ctx.fillStyle = '#4ADE80';
            ctx.font = '600 14px Poppins';
            ctx.fillText(`+${coinsCollected}`, 65, 62);

        }

        function updateMenu(dt) {
            menuBounceTimer += dt;
            if (menuBounceTimer > 1.2) {
                menuBounceTimer = 0;
                menuKangarooVel = -9.4;  // Adjusted jump height
            }
            menuKangarooVel += 25 * dt;
            menuKangarooY += menuKangarooVel;
            if (menuKangarooY > 0) {
                menuKangarooY = 0;
                menuKangarooVel = 0;
            }
        }

        function drawStartScreen() {
            const overlay = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
            overlay.addColorStop(0, 'rgba(15, 23, 42, 0.85)');
            overlay.addColorStop(1, 'rgba(15, 23, 42, 0.6)');
            ctx.fillStyle = overlay;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.textAlign = 'center';
            const centerX = CANVAS_WIDTH / 2;

            // Draw kangaroo on menu using idle animation
            const idleFrames = kangarooFrames.idle;
            if (idleFrames && idleFrames.length > 0) {
                const frame = Math.floor(menuBounceTimer * 12) % idleFrames.length;
                const frameImg = idleFrames[frame];
                const kY = 248 + menuKangarooY;  // Adjusted position
                const baseW = 156, baseH = 169;  // 30% bigger (was 120x130)
                let scaleX = 1, scaleY = 1;
                if (menuKangarooVel < -2) { scaleX = 0.85; scaleY = 1.15; }
                else if (menuKangarooY === 0 && menuKangarooVel === 0) { scaleX = 1.1; scaleY = 0.9; }
                if (frameImg) {
                    // Flip to face right
                    ctx.save();
                    ctx.translate(centerX, kY);
                    ctx.scale(-1, 1);
                    ctx.drawImage(frameImg,
                        -baseW/2 * scaleX, -baseH * scaleY, baseW * scaleX, baseH * scaleY);
                    ctx.restore();
                }
            }

            ctx.font = '800 48px Poppins';
            ctx.fillStyle = '#FFF';
            ctx.fillText('KANGAROO', centerX, 260);
            ctx.fillStyle = '#4ADE80';
            ctx.fillText('HOP', centerX, 315);

            // Draw Lottie play button
            if (lottieCanvases['playButton']) {
                const playCanvas = lottieCanvases['playButton'];
                const btnSize = 140;
                ctx.drawImage(playCanvas,
                    0, 0, playCanvas.width, playCanvas.height,
                    centerX - btnSize/2, 330, btnSize, btnSize);
            }

            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.font = '400 13px Poppins';
            ctx.fillText('SPACE or Click to jump', centerX, 560);
        }

        function drawGameOver() {
            const overlay = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
            overlay.addColorStop(0, 'rgba(15, 23, 42, 0.95)');
            overlay.addColorStop(1, 'rgba(15, 23, 42, 0.85)');
            ctx.fillStyle = overlay;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.textAlign = 'center';
            ctx.font = '800 42px Poppins';
            ctx.fillStyle = '#F87171';
            ctx.fillText('GAME OVER', CANVAS_WIDTH / 2, 140);

            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            roundRect(ctx, CANVAS_WIDTH / 2 - 120, 170, 240, 140, 16);
            ctx.fill();

            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = '400 14px Poppins';
            ctx.fillText('SCORE', CANVAS_WIDTH / 2, 200);
            ctx.fillStyle = '#FFF';
            ctx.font = '800 48px Poppins';
            ctx.fillText(Math.floor(score), CANVAS_WIDTH / 2, 255);

            if (score >= highScore && score > 0) {
                ctx.fillStyle = '#FBBF24';
                ctx.font = '700 16px Poppins';
                ctx.fillText('NEW BEST!', CANVAS_WIDTH / 2, 290);
            }

            ctx.fillStyle = '#4ADE80';
            ctx.font = '600 18px Poppins';
            ctx.fillText(`+${coinsCollected} coins`, CANVAS_WIDTH / 2, 360);

            const btnGrad = ctx.createLinearGradient(CANVAS_WIDTH / 2 - 90, 400, CANVAS_WIDTH / 2 - 90, 450);
            btnGrad.addColorStop(0, '#4ADE80');
            btnGrad.addColorStop(1, '#22C55E');
            ctx.fillStyle = btnGrad;
            roundRect(ctx, CANVAS_WIDTH / 2 - 90, 400, 180, 50, 25);
            ctx.fill();

            ctx.fillStyle = '#FFF';
            ctx.font = '700 18px Poppins';
            ctx.fillText('PLAY AGAIN', CANVAS_WIDTH / 2, 432);
        }

        // === GAME LOOP ===
        function reset() {
            // Reset kangaroo fully
            kangaroo.x = 100;
            kangaroo.y = GROUND_Y;
            kangaroo.velocityY = 0;
            kangaroo.onGround = true;
            kangaroo.wasOnGround = true;
            kangaroo.canDoubleJump = false;
            kangaroo.currentAnim = 'moving';
            kangaroo.frame = 0;
            kangaroo.frameTimer = 0;
            kangaroo.scaleX = 1;
            kangaroo.scaleY = 1;
            kangaroo.squashTime = 0;
            kangaroo.isDead = false;
            kangaroo.deathFrame = 0;
            kangaroo.deathAnimStarted = false;
            kangaroo.landSoundPlayed = false;

            // Resume Lottie animations (works for both lottie-web and DotLottie)
            Object.values(lottieAnimations).forEach(anim => {
                if (anim && typeof anim.play === 'function') anim.play();
            });

            // Reset game state
            obstacles = [];
            coins = [];
            particles = [];
            gameSpeed = INITIAL_SPEED;
            score = 0;
            coinsCollected = 0;
            gameOver = false;
            showGameOverUI = false;
            gameOverTimer = 0;
            lastObstacleTime = Date.now();
        }

        function update(dt) {
            // Jump debug mode - just update the 4 test kangaroos
            if (JUMP_DEBUG) {
                updateDebugKangaroos(dt);
                return;
            }

            // Always update particles
            updateParticles(dt);

            if (!gameStarted) {
                updateMenu(dt);
                return;
            }

            if (gameOver && kangaroo.isDead) {
                kangaroo.update(dt);
                if (!showGameOverUI) {
                    gameOverTimer += dt;
                    if (gameOverTimer >= 1.2) showGameOverUI = true;
                }
            }

            if (gameOver) return;

            const pixelsPerSecond = gameSpeed * 60;
            kangaroo.update(dt);
            updateObstacles(dt, pixelsPerSecond);
            updateCoins(dt, pixelsPerSecond);

            gameSpeed = Math.min(MAX_SPEED, gameSpeed + SPEED_INCREMENT);
            score += 6 * dt;

            if (checkCollisions()) {
                gameOver = true;
                playSound('collision');
                playSound('gameOver');
                playMusic('musicMenu');  // Switch to menu music
                // Stop all Lottie animations (works for both lottie-web and DotLottie)
                Object.values(lottieAnimations).forEach(anim => {
                    if (anim && typeof anim.pause === 'function') anim.pause();
                });
                kangaroo.die();
                if (score > highScore) {
                    highScore = Math.floor(score);
                    localStorage.setItem('kangaroo_lottie_high', highScore);
                }
                localStorage.setItem('kangaroo_lottie_coins', totalCoins);
            }
        }

        function draw() {
            ctx.fillStyle = '#4A90D9';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            drawBackground();
            drawDecorations();  // Draw sun and other background lotties
            drawGround();

            // Jump debug mode - show 4 kangaroos with different jump configs
            if (JUMP_DEBUG) {
                drawDebugKangaroos();
                // Title
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 24px Poppins';
                ctx.textAlign = 'center';
                ctx.fillText('JUMP FRAME DEBUG - Pick the best one!', CANVAS_WIDTH / 2, 50);
                return;
            }

            if (!gameStarted) {
                kangaroo.draw();
                drawStartScreen();
            } else if (gameOver) {
                drawObstacles();
                drawCoins();
                drawParticles();
                kangaroo.draw();
                drawUI();
                if (showGameOverUI) drawGameOver();
            } else {
                drawObstacles();
                drawCoins();
                drawParticles();
                kangaroo.draw();
                drawUI();
            }
        }

        function gameLoop(currentTime) {
            deltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;
            deltaTime = Math.min(deltaTime, 0.1);

            update(deltaTime);
            draw();
            requestAnimationFrame(gameLoop);
        }

        // === INPUT ===
        function handleInput() {
            if (!gameStarted) {
                playSound('buttonClick');
                gameStarted = true;
                playMusic('musicGame');  // Start game music
                reset();
            } else if (gameOver) {
                if (showGameOverUI) {
                    playSound('buttonClick');
                    playMusic('musicGame');  // Restart game music
                    reset();
                }
            } else {
                kangaroo.jump();
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault();
                handleInput();
            }
        });

        canvas.addEventListener('click', handleInput);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleInput();
        });

        // === START ===
        async function init() {
            loadingEl.textContent = 'Loading images...';

            // Load regular assets
            await new Promise(resolve => loadAssets(resolve));

            // Load Lottie animations
            loadingEl.textContent = 'Loading Lottie animations...';
            await loadAllLotties();

            // Load sprite-based obstacles (emu, magpie)
            loadingEl.textContent = 'Loading sprite obstacles...';
            await loadSpriteFrames();

            loadingEl.style.display = 'none';
            playMusic('musicMenu');  // Start menu music
            gameLoop(performance.now());
        }

        init();
    </script>
</body>
</html>
