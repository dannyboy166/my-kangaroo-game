<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kangaroo Hop - Lottie Edition</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            font-family: 'Poppins', sans-serif;
        }
        #gameContainer {
            position: relative;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5), 0 0 40px rgba(79, 172, 254, 0.15);
        }
        canvas {
            display: block;
            border-radius: 16px;
            cursor: pointer;
            transform: translateZ(0);
            will-change: transform;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            font-weight: 600;
        }
        /* Container for Lottie rendering - hidden but must render */
        #lottieContainer {
            position: fixed;
            bottom: 0;
            right: 0;
            opacity: 0.01;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="game" width="800" height="600"></canvas>
        <div id="loading">Loading...</div>
    </div>
    <div id="lottieContainer"></div>

    <script type="module">
        // Import DotLottie from jsdelivr (better CORS support)
        import { DotLottie } from 'https://cdn.jsdelivr.net/npm/@lottiefiles/dotlottie-web@0.37.0/+esm';

        // ============================================
        // KANGAROO HOP - Lottie Edition
        // Raw Canvas + Lottie Animations
        // ============================================

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d', {
            alpha: false,
            desynchronized: true
        });
        const loadingEl = document.getElementById('loading');
        const lottieContainer = document.getElementById('lottieContainer');

        // === LOTTIE SYSTEM ===
        const lottieAnimations = {};
        const lottieCanvases = {};

        // UI Lottie animations
        const LOTTIE_UI = {
            playButton: {
                src: 'assets/lottie/play_button.lottie',
                width: 120,
                height: 120
            },
        };

        // Define your Lottie obstacles here - easy to add more!
        const LOTTIE_OBSTACLES = {
            camel: {
                src: 'assets/lottie/camel.lottie',
                width: 200,
                height: 180,
                hitboxWidth: 140,
                hitboxHeight: 80,
                hitboxOffsetY: 40,
                groundOffset: 0,
                flipX: true
            },
            crocodile: {
                src: 'assets/lottie/crocodile_scooter.lottie',
                width: 280,
                height: 230,
                hitboxWidth: 72,
                hitboxHeight: 96,
                hitboxOffsetY: 50,
                groundOffset: -30,  // Push down to align with ground (moved up 10px)
                flipX: false,  // Faces left naturally
                speedMultiplier: 1.5,  // Moves 50% faster than normal obstacles
                animationSpeed: 2.0    // Animation plays 2x faster
            }
        };

        async function loadLottieAnimation(name, config) {
            return new Promise((resolve, reject) => {
                // Create a DOM canvas in the hidden container - DotLottie needs visible DOM canvas
                const lottieCanvas = document.createElement('canvas');
                lottieCanvas.id = `lottie-${name}`;
                lottieCanvas.width = config.width;
                lottieCanvas.height = config.height;
                lottieContainer.appendChild(lottieCanvas);  // Use the hidden container

                try {
                    const dotLottie = new DotLottie({
                        canvas: lottieCanvas,
                        src: config.src,
                        loop: true,
                        autoplay: true,
                        speed: config.animationSpeed || 1.0  // Animation playback speed
                    });

                    dotLottie.addEventListener('load', () => {
                        lottieAnimations[name] = dotLottie;
                        lottieCanvases[name] = lottieCanvas;
                        resolve(dotLottie);
                    });

                    dotLottie.addEventListener('loadError', (error) => {
                        console.error(`✗ Failed to load Lottie: ${name}`, error);
                        reject(error);
                    });

                    // Timeout fallback
                    setTimeout(() => {
                        if (!lottieAnimations[name] && dotLottie.isLoaded) {
                            lottieAnimations[name] = dotLottie;
                            lottieCanvases[name] = lottieCanvas;
                            resolve(dotLottie);
                        }
                    }, 3000);
                } catch (err) {
                    console.error(`Error creating DotLottie for ${name}:`, err);
                    reject(err);
                }
            });
        }

        async function loadAllLotties() {
            // Load obstacle lotties
            const obstaclePromises = Object.entries(LOTTIE_OBSTACLES).map(([name, config]) =>
                loadLottieAnimation(name, config).catch(() => null)
            );
            // Load UI lotties
            const uiPromises = Object.entries(LOTTIE_UI).map(([name, config]) =>
                loadLottieAnimation(name, config).catch(() => null)
            );
            await Promise.all([...obstaclePromises, ...uiPromises]);
        }

        // === AUDIO ===
        const sounds = {
            jump: new Audio('assets/audio/sfx/jump.mp3'),
            doubleJump: new Audio('assets/audio/sfx/double_jump.mp3'),
            land: new Audio('assets/audio/sfx/land.mp3'),
            coin: new Audio('assets/audio/sfx/coin_collect.mp3'),
            collision: new Audio('assets/audio/sfx/collision.mp3'),
            gameOver: new Audio('assets/audio/sfx/game_over.mp3'),
            buttonClick: new Audio('assets/audio/sfx/button_click.mp3'),
            // Music
            musicMenu: new Audio('assets/audio/music/menu_music.mp3'),
            musicGame: new Audio('assets/audio/music/outback_music.mp3')
        };

        sounds.jump.volume = 0.7;
        sounds.doubleJump.volume = 0.8;
        sounds.land.volume = 0.6;
        sounds.coin.volume = 0.9;
        sounds.collision.volume = 0.8;
        sounds.gameOver.volume = 1.0;
        sounds.buttonClick.volume = 0.6;
        sounds.musicMenu.volume = 0.3;
        sounds.musicGame.volume = 0.4;
        sounds.musicMenu.loop = true;
        sounds.musicGame.loop = true;

        let currentMusic = null;

        function playMusic(name) {
            if (!soundEnabled) return;
            // Stop current music
            if (currentMusic) {
                currentMusic.pause();
                currentMusic.currentTime = 0;
            }
            const music = sounds[name];
            if (music) {
                currentMusic = music;
                music.play().catch(() => {});
            }
        }

        function stopMusic() {
            if (currentMusic) {
                currentMusic.pause();
                currentMusic.currentTime = 0;
                currentMusic = null;
            }
        }

        function playSound(name) {
            if (!soundEnabled) return;
            const sound = sounds[name];
            if (sound) {
                sound.currentTime = 0;
                sound.play().catch(() => {});
            }
        }

        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        // === CONSTANTS ===
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const GROUND_Y = 500;
        const GRAVITY = 1.0;
        const JUMP_FORCE = -22;
        const INITIAL_SPEED = 7;
        const MAX_SPEED = 14;
        const SPEED_INCREMENT = 0.002;
        const DEBUG = true;  // Set true to see hitboxes
        const JUMP_DEBUG = false;  // Show 4 kangaroos with different jump animations
        const SPAWN_DEBUG = true;  // Spawn camel → croc pattern for testing gaps
        // =====================================================
        // CROC GAP SETTINGS (tested at starting speed 7)
        // =====================================================
        // The crocodile moves 1.5x faster than other obstacles, so spacing matters!
        //
        // VALID RANGES:
        // - 350-650px: "Double jump zone" - jump over both without landing
        // - 850px+:    "Landing zone" - land between obstacles, then jump croc
        //
        // FORBIDDEN:
        // - 650-850px: Too tricky - not enough time to land OR double jump
        //
        // The spawn logic randomly picks from valid ranges only.
        // =====================================================
        const CROC_GAP_MIN_DOUBLE = 350;   // Minimum for double jump
        const CROC_GAP_MAX_DOUBLE = 650;   // Maximum for double jump
        const CROC_GAP_MIN_LANDING = 850;  // Minimum for landing between
        const CROC_GAP_MAX_LANDING = 1000; // Maximum for landing (keeps it challenging)

        // For debug testing - set to specific value or null to use random
        const CROC_GAP_PIXELS = null;  // null = use random valid range

        // Gap from croc back to next camel (croc → camel)
        const CAMEL_AFTER_CROC_GAP = 1000;  // Fixed for testing

        // === PARTICLES ===
        let particles = [];

        function spawnDustParticles(x, y) {
            const count = 8 + Math.floor(Math.random() * 5);
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 40,
                    y: y,
                    vx: (Math.random() - 0.5) * 150,
                    vy: -Math.random() * 80 - 20,
                    size: 4 + Math.random() * 8,
                    life: 0.4 + Math.random() * 0.3,
                    maxLife: 0.4 + Math.random() * 0.3,
                    color: Math.random() > 0.5 ? '#C4A574' : '#A68B5B',
                    type: 'dust'
                });
            }
        }

        function spawnCoinSparkles(x, y) {
            const count = 12 + Math.floor(Math.random() * 6);
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
                const speed = 100 + Math.random() * 150;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 3 + Math.random() * 5,
                    life: 0.3 + Math.random() * 0.3,
                    maxLife: 0.3 + Math.random() * 0.3,
                    color: Math.random() > 0.5 ? '#FFD700' : '#FFF176',
                    type: 'sparkle'
                });
            }
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;

                if (p.type === 'dust') {
                    p.vy += 200 * dt;
                } else if (p.type === 'sparkle') {
                    p.vx *= 0.95;
                    p.vy *= 0.95;
                }

                p.life -= dt;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                const alpha = p.life / p.maxLife;

                if (p.type === 'sparkle') {
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(Math.round(p.x), Math.round(p.y), p.size * alpha * 1.5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(Math.round(p.x), Math.round(p.y), p.size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.globalAlpha = alpha * 0.7;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(Math.round(p.x), Math.round(p.y), p.size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            ctx.globalAlpha = 1;
        }

        // === ASSETS ===
        const assets = {};

        // Kangaroo animation frames (from Phaser version's character system)
        const KANGAROO_ANIMATIONS = {
            moving: { prefix: 'red_kangaroo_no_joey_moving', frameCount: 16, frameRate: 20 },
            jump: { prefix: 'red_kangaroo_no_joey_jump_from_idle', frameStart: 0, frameEnd: 6, frameRate: 20, hold: true },  // Frames 0-6, hold on last
            die: { prefix: 'red_kangaroo_no_joey_die', frameCount: 5, frameRate: 10 },
            idle: { prefix: 'red_kangaroo_no_joey_idle', frameCount: 20, frameRate: 12 }
        };

        // Store animation frames
        const kangarooFrames = {
            moving: [],
            jump: [],
            die: [],
            idle: []
        };

        const assetList = [
            { name: 'coin', src: 'assets/images/coin/coin-64x64.png' },
            // UI Assets
            { name: 'btn_green', src: 'assets/images/ui/buttons/bttn_green.png' },
            { name: 'btn_blue', src: 'assets/images/ui/buttons/bttn_blue.png' },
            { name: 'btn_pink', src: 'assets/images/ui/buttons/bttn_pink.png' },
            { name: 'btn_gray', src: 'assets/images/ui/buttons/bttn_gray.png' },
            { name: 'btn_long_green', src: 'assets/images/ui/buttons/bttn_long_green.png' },
            { name: 'panel_score', src: 'assets/images/ui/title/back_score.png' },
            { name: 'panel_small', src: 'assets/images/ui/title/back_small_progress.png' },
            { name: 'ribbon_green', src: 'assets/images/ui/lable/r_lable_blue.png' },
            { name: 'ribbon_orange', src: 'assets/images/ui/lable/r_lable_orange.png' },
            { name: 'close_btn', src: 'assets/images/ui/title/close.png' }
        ];

        function loadAssets(callback) {
            let loaded = 0;
            let total = assetList.length;

            // Calculate total frames to load
            Object.values(KANGAROO_ANIMATIONS).forEach(anim => {
                if (anim.frameStart !== undefined) {
                    total += (anim.frameEnd - anim.frameStart + 1);
                } else {
                    total += anim.frameCount;
                }
            });

            if (total === 0) {
                callback();
                return;
            }

            const checkComplete = () => {
                loadingEl.textContent = `Loading... ${Math.floor(loaded / total * 100)}%`;
                if (loaded === total) callback();
            };

            // Load regular assets
            assetList.forEach(asset => {
                const img = new Image();
                img.onload = () => {
                    assets[asset.name] = img;
                    loaded++;
                    checkComplete();
                };
                img.onerror = () => {
                    console.error(`Failed to load: ${asset.name}`);
                    loaded++;
                    checkComplete();
                };
                img.src = asset.src;
            });

            // Load kangaroo animation frames
            Object.entries(KANGAROO_ANIMATIONS).forEach(([animName, config]) => {
                const start = config.frameStart !== undefined ? config.frameStart : 0;
                const end = config.frameEnd !== undefined ? config.frameEnd : config.frameCount - 1;

                let localIndex = 0;
                for (let i = start; i <= end; i++) {
                    const frameNum = String(i).padStart(3, '0');
                    const img = new Image();
                    const idx = localIndex;  // Capture for closure
                    img.onload = () => {
                        kangarooFrames[animName][idx] = img;
                        loaded++;
                        checkComplete();
                    };
                    img.onerror = () => {
                        console.error(`Failed to load kangaroo frame: ${animName}_${frameNum}`);
                        loaded++;
                        checkComplete();
                    };
                    img.src = `assets/characters/kangaroo/brown/${config.prefix}_${frameNum}.png`;
                    localIndex++;
                }
            });
        }

        // === GAME STATE ===
        let gameSpeed = INITIAL_SPEED;
        let score = 0;
        let highScore = parseInt(localStorage.getItem('kangaroo_lottie_high')) || 0;
        let coinsCollected = 0;
        let totalCoins = parseInt(localStorage.getItem('kangaroo_lottie_coins')) || 0;
        let gameOver = false;
        let showGameOverUI = false;
        let gameOverTimer = 0;
        let gameStarted = false;
        let soundEnabled = true;
        let deltaTime = 0;
        let lastFrameTime = performance.now();

        // Menu animation
        let menuKangarooY = 0;
        let menuKangarooVel = 0;
        let menuBounceTimer = 0;

        // === KANGAROO ===
        const DOUBLE_JUMP_FORCE = -17;

        const kangaroo = {
            x: 100,
            y: GROUND_Y,
            width: 154,           // Match Phaser version display size
            height: 178,
            velocityY: 0,
            onGround: true,
            wasOnGround: true,
            canDoubleJump: false,

            // Animation state
            currentAnim: 'moving',
            frame: 0,
            frameTimer: 0,

            // Squash & stretch
            scaleX: 1,
            scaleY: 1,
            squashTime: 0,

            // Death state
            isDead: false,
            deathFrame: 0,
            deathAnimStarted: false,
            landSoundPlayed: false,

            update(dt) {
                // Update animation frame
                this.frameTimer += dt;
                const anim = KANGAROO_ANIMATIONS[this.currentAnim];
                const frameDelay = 1 / anim.frameRate;

                if (this.frameTimer >= frameDelay) {
                    this.frameTimer = 0;

                    if (this.isDead && this.deathAnimStarted) {
                        // Death animation plays once
                        if (this.deathFrame < KANGAROO_ANIMATIONS.die.frameCount - 1) {
                            this.deathFrame++;
                        }
                    } else if (!this.isDead) {
                        const maxFrames = kangarooFrames[this.currentAnim].length;
                        // Check if animation should hold on last frame
                        if (anim.hold && this.frame >= maxFrames - 1) {
                            // Stay on last frame
                            this.frame = maxFrames - 1;
                        } else {
                            // Loop animation
                            this.frame = (this.frame + 1) % maxFrames;
                        }
                    }
                }

                // When dead, keep falling until hitting ground
                if (this.isDead) {
                    if (!this.onGround) {
                        // Keep falling
                        const gravityPerSecond = GRAVITY * 60;
                        this.velocityY += gravityPerSecond * dt;
                        this.y += this.velocityY * dt * 60;

                        if (this.y >= GROUND_Y) {
                            this.y = GROUND_Y;
                            this.velocityY = 0;
                            this.onGround = true;
                            // Now start death animation
                            this.deathAnimStarted = true;
                            this.currentAnim = 'die';
                            this.deathFrame = 0;
                            this.frame = 0;
                            spawnDustParticles(this.x, GROUND_Y);
                        }
                    }
                    return;
                }

                this.wasOnGround = this.onGround;
                const gravityPerSecond = GRAVITY * 60;
                this.velocityY += gravityPerSecond * dt;
                this.y += this.velocityY * dt * 60;

                // Play land sound slightly before hitting ground (when close and descending)
                if (!this.onGround && this.velocityY > 0 && this.y > GROUND_Y - 30 && !this.landSoundPlayed) {
                    playSound('land');
                    this.landSoundPlayed = true;
                }

                if (this.y >= GROUND_Y) {
                    this.y = GROUND_Y;
                    this.velocityY = 0;
                    this.onGround = true;
                    this.canDoubleJump = false;
                    this.landSoundPlayed = false;  // Reset for next jump

                    // Switch to moving animation when landing
                    if (!this.wasOnGround) {
                        this.currentAnim = 'moving';
                        this.frame = 0;
                        this.squashTime = 0.15;
                        this.scaleX = 1.3;
                        this.scaleY = 0.7;
                        // Spawn dust particles!
                        spawnDustParticles(this.x, GROUND_Y);
                    }
                } else {
                    // In air - use jump animation
                    if (this.currentAnim !== 'jump') {
                        this.currentAnim = 'jump';
                        this.frame = 0;
                    }
                }

                // Animate squash back to normal
                if (this.squashTime > 0) {
                    this.squashTime -= dt;
                    this.scaleX += (1 - this.scaleX) * 10 * dt;
                    this.scaleY += (1 - this.scaleY) * 10 * dt;
                } else {
                    this.scaleX = 1;
                    this.scaleY = 1;
                }
            },

            die() {
                this.isDead = true;
                // If already on ground, start death anim immediately
                if (this.onGround) {
                    this.deathAnimStarted = true;
                    this.currentAnim = 'die';
                    this.deathFrame = 0;
                    this.frame = 0;
                } else {
                    this.deathAnimStarted = false;  // Wait until on ground
                }
            },

            jump() {
                if (this.isDead) return;
                if (this.onGround) {
                    this.velocityY = JUMP_FORCE;
                    this.onGround = false;
                    this.canDoubleJump = true;
                    this.landSoundPlayed = false;  // Reset for landing
                    this.currentAnim = 'jump';
                    this.frame = 0;
                    playSound('jump');
                    this.scaleX = 0.8;
                    this.scaleY = 1.2;
                    this.squashTime = 0.1;
                } else if (this.canDoubleJump) {
                    this.velocityY = DOUBLE_JUMP_FORCE;
                    this.canDoubleJump = false;
                    this.frame = 0;
                    playSound('doubleJump');
                    this.scaleX = 0.8;
                    this.scaleY = 1.2;
                    this.squashTime = 0.1;
                }
            },

            draw() {
                const scaledWidth = this.width * this.scaleX;
                const scaledHeight = this.height * this.scaleY;
                const drawX = Math.round(this.x);
                const drawY = Math.round(this.y);

                ctx.save();

                // Get the right frame
                let frameImg;
                if (this.isDead) {
                    frameImg = kangarooFrames.die[this.deathFrame];
                } else {
                    frameImg = kangarooFrames[this.currentAnim][this.frame];
                }

                if (frameImg) {
                    // Flip horizontally - kangaroo sprites face left, we need right
                    // Offset to align feet with ground (sprites have padding)
                    const groundAdjust = 30;
                    ctx.translate(drawX, drawY + groundAdjust);
                    ctx.scale(-1, 1);  // Flip horizontally
                    ctx.drawImage(
                        frameImg,
                        -scaledWidth / 2,
                        -scaledHeight,
                        scaledWidth,
                        scaledHeight
                    );
                }

                ctx.restore();

                if (DEBUG) {
                    const bounds = this.getBounds();
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);
                }
            },

            getBounds() {
                // Hitbox aligned with visual sprite (+30 ground adjust, +20 forward)
                return {
                    x: this.x - 36 + 20,  // Moved 20px forward
                    y: this.y - 120 + 30,
                    width: 72,
                    height: 75
                };
            }
        };

        // === DEBUG: 4 KANGAROOS WITH DIFFERENT JUMP ANIMATIONS ===
        const debugJumpConfigs = [
            { label: '0-6', start: 0, end: 6 },
            { label: '0-8', start: 0, end: 8 },
            { label: '2-6', start: 2, end: 6 },
            { label: '2-8', start: 2, end: 8 }
        ];

        const debugKangaroos = debugJumpConfigs.map((config, i) => ({
            x: 100 + i * 180,
            y: GROUND_Y,
            velocityY: 0,
            onGround: true,
            frame: 0,
            frameTimer: 0,
            jumpTimer: 0,
            jumpStart: config.start,
            jumpEnd: config.end,
            label: config.label,
            currentAnim: 'moving',
            width: 100,
            height: 116
        }));

        function updateDebugKangaroos(dt) {
            debugKangaroos.forEach(k => {
                // Auto jump every 2 seconds
                k.jumpTimer += dt;
                if (k.jumpTimer > 2 && k.onGround) {
                    k.velocityY = JUMP_FORCE;
                    k.onGround = false;
                    k.currentAnim = 'jump';
                    k.frame = k.jumpStart;
                    k.jumpTimer = 0;
                }

                // Physics
                k.velocityY += GRAVITY * 60 * dt;
                k.y += k.velocityY * dt * 60;

                if (k.y >= GROUND_Y) {
                    k.y = GROUND_Y;
                    k.velocityY = 0;
                    k.onGround = true;
                    k.currentAnim = 'moving';
                    k.frame = 0;
                }

                // Animate
                k.frameTimer += dt;
                const frameDelay = 1 / 20;
                if (k.frameTimer >= frameDelay) {
                    k.frameTimer = 0;
                    if (k.currentAnim === 'jump') {
                        if (k.frame < k.jumpEnd) {
                            k.frame++;
                        }
                        // Hold on last frame
                    } else {
                        k.frame = (k.frame + 1) % kangarooFrames.moving.length;
                    }
                }
            });
        }

        function drawDebugKangaroos() {
            debugKangaroos.forEach(k => {
                const frameImg = k.currentAnim === 'jump'
                    ? kangarooFrames.jump[k.frame]
                    : kangarooFrames.moving[k.frame];

                if (frameImg) {
                    ctx.save();
                    ctx.translate(Math.round(k.x), Math.round(k.y) + 30);
                    ctx.scale(-1, 1);
                    ctx.drawImage(frameImg, -k.width / 2, -k.height, k.width, k.height);
                    ctx.restore();
                }

                // Label
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 16px Poppins';
                ctx.textAlign = 'center';
                ctx.fillText(k.label, k.x, GROUND_Y + 30);
            });
        }

        // === OBSTACLES (Now with Lottie support!) ===
        let obstacles = [];
        let lastObstacleTime = 0;
        let obstacleInterval = 1800 + Math.random() * 1200;  // 1800-3000ms between pairs

        let debugSpawnIndex = 0;  // Alternates: 0=camel, 1=croc

        function spawnObstacle() {
            if (SPAWN_DEBUG) {
                // Debug mode: camel → croc pattern
                const pattern = ['camel', 'crocodile'];
                const name = pattern[debugSpawnIndex % 2];
                const config = LOTTIE_OBSTACLES[name];

                if (config && lottieAnimations[name]) {
                    obstacles.push({
                        x: CANVAS_WIDTH + 50,
                        y: GROUND_Y - config.groundOffset,
                        width: config.width,
                        height: config.height,
                        hitboxWidth: config.hitboxWidth,
                        hitboxHeight: config.hitboxHeight,
                        hitboxOffsetY: config.hitboxOffsetY || 0,
                        speedMultiplier: config.speedMultiplier || 1.0,
                        lottie: name,
                        isLottie: true
                    });

                    // Spawn pattern: camel → croc (repeat)
                    if (debugSpawnIndex % 2 === 0) {
                        const crocConfig = LOTTIE_OBSTACLES['crocodile'];

                        // Calculate gap - use fixed value for testing, or random valid range
                        let crocGap;
                        if (CROC_GAP_PIXELS !== null) {
                            crocGap = CROC_GAP_PIXELS;  // Debug: fixed value
                        } else {
                            // Random: 50% chance double jump zone, 50% chance landing zone
                            if (Math.random() < 0.5) {
                                crocGap = CROC_GAP_MIN_DOUBLE + Math.random() * (CROC_GAP_MAX_DOUBLE - CROC_GAP_MIN_DOUBLE);
                            } else {
                                crocGap = CROC_GAP_MIN_LANDING + Math.random() * (CROC_GAP_MAX_LANDING - CROC_GAP_MIN_LANDING);
                            }
                        }

                        // Spawn croc behind camel
                        obstacles.push({
                            x: CANVAS_WIDTH + 50 + crocGap,
                            y: GROUND_Y - crocConfig.groundOffset,
                            width: crocConfig.width,
                            height: crocConfig.height,
                            hitboxWidth: crocConfig.hitboxWidth,
                            hitboxHeight: crocConfig.hitboxHeight,
                            hitboxOffsetY: crocConfig.hitboxOffsetY || 0,
                            speedMultiplier: crocConfig.speedMultiplier || 1.0,
                            lottie: 'crocodile',
                            isLottie: true
                        });

                        debugSpawnIndex++;  // Skip next since we spawned both
                    }
                    debugSpawnIndex++;
                }
                return;
            }

            // Normal mode: random Lottie obstacle
            const lottieNames = Object.keys(lottieAnimations);

            if (lottieNames.length > 0) {
                const name = lottieNames[Math.floor(Math.random() * lottieNames.length)];
                const config = LOTTIE_OBSTACLES[name];

                obstacles.push({
                    x: CANVAS_WIDTH + 50,
                    y: GROUND_Y - config.groundOffset,
                    width: config.width,
                    height: config.height,
                    hitboxWidth: config.hitboxWidth,
                    hitboxHeight: config.hitboxHeight,
                    hitboxOffsetY: config.hitboxOffsetY || 0,
                    speedMultiplier: config.speedMultiplier || 1.0,
                    lottie: name,
                    isLottie: true
                });
            }
        }

        function updateObstacles(dt, pixelsPerSecond) {
            const now = Date.now();

            if (now - lastObstacleTime > obstacleInterval) {
                spawnObstacle();
                lastObstacleTime = now;
                obstacleInterval = 1800 + Math.random() * 1200;  // 1800-3000ms between pairs
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                const speedMult = obs.speedMultiplier || 1.0;
                obs.x -= pixelsPerSecond * speedMult * dt;

                if (obs.x < -150) {
                    obstacles.splice(i, 1);
                    score += 10;
                }
            }
        }

        function drawObstacles() {
            obstacles.forEach(obs => {
                if (obs.isLottie && lottieCanvases[obs.lottie]) {
                    const offCanvas = lottieCanvases[obs.lottie];
                    const config = LOTTIE_OBSTACLES[obs.lottie];

                    ctx.save();

                    // Adjust to align with ground (Lottie may have padding)
                    const groundAdjust = 40;

                    // Flip horizontally if needed (to face left)
                    if (config && config.flipX) {
                        ctx.translate(obs.x, 0);
                        ctx.scale(-1, 1);
                        ctx.drawImage(
                            offCanvas,
                            0, 0, offCanvas.width, offCanvas.height,
                            -obs.width / 2,
                            Math.round(obs.y - obs.height + groundAdjust),
                            obs.width,
                            obs.height
                        );
                    } else {
                        ctx.drawImage(
                            offCanvas,
                            0, 0, offCanvas.width, offCanvas.height,
                            Math.round(obs.x - obs.width / 2),
                            Math.round(obs.y - obs.height + groundAdjust),
                            obs.width,
                            obs.height
                        );
                    }

                    ctx.restore();
                }

                // Debug: draw hitbox (adjusted for ground offset)
                if (DEBUG) {
                    const hbWidth = obs.hitboxWidth || obs.width - 20;
                    const hbHeight = obs.hitboxHeight || obs.height - 20;
                    const hbOffsetY = obs.hitboxOffsetY || 0;
                    const groundAdjust = 40;  // Match visual offset
                    ctx.strokeStyle = '#FF0000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(
                        Math.round(obs.x - hbWidth / 2),
                        Math.round(obs.y - hbHeight - hbOffsetY + groundAdjust),
                        hbWidth,
                        hbHeight
                    );
                }
            });
        }

        // === COINS ===
        let coins = [];

        function spawnCoin(x) {
            coins.push({
                x: x || CANVAS_WIDTH + Math.random() * 200,
                y: GROUND_Y - 50 - Math.random() * 80,
                size: 40,
                frame: 0,
                frameTimer: 0,
                collected: false
            });
        }

        function updateCoins(dt, pixelsPerSecond) {
            if (Math.random() < 0.6 * dt) spawnCoin();

            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                coin.x -= pixelsPerSecond * dt;
                coin.frameTimer += dt;
                if (coin.frameTimer >= 0.04) {
                    coin.frameTimer = 0;
                    coin.frame = (coin.frame + 1) % 25;
                }

                if (!coin.collected) {
                    const k = kangaroo.getBounds();
                    if (k.x < coin.x + coin.size && k.x + k.width > coin.x - coin.size &&
                        k.y < coin.y + coin.size && k.y + k.height > coin.y - coin.size) {
                        coin.collected = true;
                        coinsCollected++;
                        totalCoins++;
                        score += 5;
                        playSound('coin');
                        spawnCoinSparkles(coin.x, coin.y);
                    }
                }

                if (coin.x < -50 || coin.collected) {
                    coins.splice(i, 1);
                }
            }
        }

        function drawCoins() {
            coins.forEach(coin => {
                if (assets.coin) {
                    ctx.drawImage(
                        assets.coin,
                        coin.frame * 64, 0, 64, 64,
                        Math.round(coin.x - coin.size / 2),
                        Math.round(coin.y - coin.size / 2),
                        coin.size, coin.size
                    );
                } else {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(coin.x, coin.y, coin.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        // === COLLISION ===
        function checkCollisions() {
            const k = kangaroo.getBounds();

            for (const obs of obstacles) {
                const hbWidth = obs.hitboxWidth || obs.width - 20;
                const hbHeight = obs.hitboxHeight || obs.height - 20;
                const hbOffsetY = obs.hitboxOffsetY || 0;
                const groundAdjust = 40;  // Match visual offset
                const o = {
                    x: obs.x - hbWidth / 2,
                    y: obs.y - hbHeight - hbOffsetY + groundAdjust,
                    width: hbWidth,
                    height: hbHeight
                };

                if (k.x < o.x + o.width && k.x + k.width > o.x &&
                    k.y < o.y + o.height && k.y + k.height > o.y) {
                    return true;
                }
            }
            return false;
        }

        // === BACKGROUND ===
        function drawBackground() {
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, CANVAS_WIDTH, GROUND_Y);
        }

        function drawGround() {
            // Simple brown ground
            ctx.fillStyle = '#8B7355';
            ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, CANVAS_HEIGHT - GROUND_Y);

            // Ground line
            ctx.fillStyle = '#6B5344';
            ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, 4);
        }

        // === UI ===
        function drawUI() {
            // Score panel (top right)
            if (assets.panel_score) {
                ctx.drawImage(assets.panel_score, CANVAS_WIDTH - 170, 5, 165, 75);
            } else {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                roundRect(ctx, CANVAS_WIDTH - 160, 10, 150, 70, 12);
                ctx.fill();
            }

            ctx.fillStyle = '#FFF';
            ctx.font = '700 32px Poppins';
            ctx.textAlign = 'right';
            ctx.shadowColor = 'rgba(0,0,0,0.4)';
            ctx.shadowBlur = 4;
            ctx.fillText(Math.floor(score), CANVAS_WIDTH - 25, 50);
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.font = '500 13px Poppins';
            ctx.fillText(`BEST: ${Math.floor(highScore)}`, CANVAS_WIDTH - 25, 70);

            // Coin panel (top left)
            if (assets.panel_small) {
                ctx.drawImage(assets.panel_small, 5, 5, 140, 75);
            } else {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                roundRect(ctx, 10, 10, 130, 70, 12);
                ctx.fill();
            }

            // Draw coin icon
            if (assets.coin) {
                ctx.drawImage(assets.coin, 0, 0, 64, 64, 18, 18, 40, 40);
            } else {
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(38, 38, 15, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.fillStyle = '#FFF';
            ctx.font = '700 24px Poppins';
            ctx.textAlign = 'left';
            ctx.shadowColor = 'rgba(0,0,0,0.4)';
            ctx.shadowBlur = 4;
            ctx.fillText(totalCoins, 65, 44);
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#4ADE80';
            ctx.font = '600 14px Poppins';
            ctx.fillText(`+${coinsCollected}`, 65, 64);

            // Debug info (only in debug mode)
            if (DEBUG) {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                roundRect(ctx, 10, 90, 180, 30, 8);
                ctx.fill();
                ctx.fillStyle = '#4ADE80';
                ctx.font = '600 11px Poppins';
                ctx.fillText(`Lottie: ${Object.keys(lottieAnimations).length} | Speed: ${gameSpeed.toFixed(1)}`, 20, 110);
            }

            // Debug: show croc gap (only in spawn debug)
            if (SPAWN_DEBUG && DEBUG) {
                ctx.fillStyle = 'rgba(255,100,0,0.6)';
                roundRect(ctx, 10, 125, 200, 25, 8);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = '600 11px Poppins';
                const gapText = CROC_GAP_PIXELS !== null
                    ? `Gap: ${CROC_GAP_PIXELS}px (fixed)`
                    : `Gap: Random valid`;
                ctx.fillText(gapText, 20, 142);
            }
        }

        function updateMenu(dt) {
            menuBounceTimer += dt;
            if (menuBounceTimer > 1.2) {
                menuBounceTimer = 0;
                menuKangarooVel = -8;
            }
            menuKangarooVel += 25 * dt;
            menuKangarooY += menuKangarooVel;
            if (menuKangarooY > 0) {
                menuKangarooY = 0;
                menuKangarooVel = 0;
            }
        }

        function drawStartScreen() {
            const overlay = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
            overlay.addColorStop(0, 'rgba(15, 23, 42, 0.85)');
            overlay.addColorStop(1, 'rgba(15, 23, 42, 0.6)');
            ctx.fillStyle = overlay;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.textAlign = 'center';
            const centerX = CANVAS_WIDTH / 2;

            // Draw kangaroo on menu using idle animation
            const idleFrames = kangarooFrames.idle;
            if (idleFrames && idleFrames.length > 0) {
                const frame = Math.floor(menuBounceTimer * 12) % idleFrames.length;
                const frameImg = idleFrames[frame];
                const kY = 200 + menuKangarooY;
                let scaleX = 1, scaleY = 1;
                if (menuKangarooVel < -2) { scaleX = 0.85; scaleY = 1.15; }
                else if (menuKangarooY === 0 && menuKangarooVel === 0) { scaleX = 1.1; scaleY = 0.9; }
                if (frameImg) {
                    ctx.save();
                    ctx.translate(centerX, kY);
                    ctx.scale(-1, 1);
                    ctx.drawImage(frameImg,
                        -60 * scaleX, -130 * scaleY, 120 * scaleX, 130 * scaleY);
                    ctx.restore();
                }
            }

            // Draw title ribbon behind text
            if (assets.ribbon_orange) {
                const ribbonW = 340;
                const ribbonH = 100;
                ctx.drawImage(assets.ribbon_orange, centerX - ribbonW/2, 230, ribbonW, ribbonH);
            }

            // Title text on ribbon
            ctx.font = '800 42px Poppins';
            ctx.fillStyle = '#FFF';
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetY = 3;
            ctx.fillText('KANGAROO', centerX, 270);
            ctx.fillStyle = '#FFE066';
            ctx.fillText('HOP', centerX, 318);
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;

            // Draw Lottie play button
            if (lottieCanvases['playButton']) {
                const playCanvas = lottieCanvases['playButton'];
                const btnSize = 140;
                ctx.drawImage(playCanvas,
                    0, 0, playCanvas.width, playCanvas.height,
                    centerX - btnSize/2, 350, btnSize, btnSize);
            }

            // High score display
            if (highScore > 0) {
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                roundRect(ctx, centerX - 80, 500, 160, 40, 20);
                ctx.fill();
                ctx.fillStyle = '#FFD700';
                ctx.font = '600 16px Poppins';
                ctx.fillText(`Best: ${highScore}`, centerX, 526);
            }

            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.font = '400 13px Poppins';
            ctx.fillText('SPACE or Tap to jump', centerX, 570);
        }

        function drawGameOver() {
            const overlay = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
            overlay.addColorStop(0, 'rgba(15, 23, 42, 0.95)');
            overlay.addColorStop(1, 'rgba(15, 23, 42, 0.85)');
            ctx.fillStyle = overlay;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.textAlign = 'center';
            const centerX = CANVAS_WIDTH / 2;

            // Game Over title with ribbon
            if (assets.ribbon_orange) {
                const ribbonW = 280;
                const ribbonH = 70;
                ctx.drawImage(assets.ribbon_orange, centerX - ribbonW/2, 95, ribbonW, ribbonH);
            }
            ctx.font = '800 36px Poppins';
            ctx.fillStyle = '#FFF';
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 6;
            ctx.fillText('GAME OVER', centerX, 140);
            ctx.shadowBlur = 0;

            // Score panel
            if (assets.panel_score) {
                ctx.drawImage(assets.panel_score, centerX - 100, 175, 200, 120);
            } else {
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                roundRect(ctx, centerX - 120, 170, 240, 140, 16);
                ctx.fill();
            }

            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.font = '500 14px Poppins';
            ctx.fillText('SCORE', centerX, 210);
            ctx.fillStyle = '#FFF';
            ctx.font = '800 52px Poppins';
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 4;
            ctx.fillText(Math.floor(score), centerX, 268);
            ctx.shadowBlur = 0;

            // New best indicator
            if (score >= highScore && score > 0) {
                ctx.fillStyle = '#FFD700';
                ctx.font = '700 18px Poppins';
                ctx.fillText('NEW BEST!', centerX, 300);
            }

            // Coins earned
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            roundRect(ctx, centerX - 70, 330, 140, 40, 20);
            ctx.fill();

            // Coin icon
            if (assets.coin) {
                ctx.drawImage(assets.coin, 0, 0, 64, 64, centerX - 58, 335, 30, 30);
            }
            ctx.fillStyle = '#4ADE80';
            ctx.font = '700 18px Poppins';
            ctx.fillText(`+${coinsCollected}`, centerX + 10, 357);

            // Play Again button with image
            if (assets.btn_long_green) {
                const btnW = 200;
                const btnH = 60;
                ctx.drawImage(assets.btn_long_green, centerX - btnW/2, 400, btnW, btnH);
            } else {
                const btnGrad = ctx.createLinearGradient(centerX - 90, 400, centerX - 90, 450);
                btnGrad.addColorStop(0, '#4ADE80');
                btnGrad.addColorStop(1, '#22C55E');
                ctx.fillStyle = btnGrad;
                roundRect(ctx, centerX - 90, 400, 180, 50, 25);
                ctx.fill();
            }

            ctx.fillStyle = '#FFF';
            ctx.font = '700 20px Poppins';
            ctx.shadowColor = 'rgba(0,0,0,0.4)';
            ctx.shadowBlur = 4;
            ctx.fillText('PLAY AGAIN', centerX, 437);
            ctx.shadowBlur = 0;

            // Best score reminder
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.font = '400 14px Poppins';
            ctx.fillText(`Best: ${highScore}`, centerX, 490);
        }

        // === GAME LOOP ===
        function reset() {
            // Reset kangaroo fully
            kangaroo.x = 100;
            kangaroo.y = GROUND_Y;
            kangaroo.velocityY = 0;
            kangaroo.onGround = true;
            kangaroo.wasOnGround = true;
            kangaroo.canDoubleJump = false;
            kangaroo.currentAnim = 'moving';
            kangaroo.frame = 0;
            kangaroo.frameTimer = 0;
            kangaroo.scaleX = 1;
            kangaroo.scaleY = 1;
            kangaroo.squashTime = 0;
            kangaroo.isDead = false;
            kangaroo.deathFrame = 0;
            kangaroo.deathAnimStarted = false;
            kangaroo.landSoundPlayed = false;

            // Resume Lottie animations
            Object.values(lottieAnimations).forEach(anim => anim.play());

            // Reset game state
            obstacles = [];
            coins = [];
            particles = [];
            gameSpeed = INITIAL_SPEED;
            score = 0;
            coinsCollected = 0;
            gameOver = false;
            showGameOverUI = false;
            gameOverTimer = 0;
            lastObstacleTime = Date.now();
        }

        function update(dt) {
            // Jump debug mode - just update the 4 test kangaroos
            if (JUMP_DEBUG) {
                updateDebugKangaroos(dt);
                return;
            }

            // Always update particles
            updateParticles(dt);

            if (!gameStarted) {
                updateMenu(dt);
                return;
            }

            if (gameOver && kangaroo.isDead) {
                kangaroo.update(dt);
                if (!showGameOverUI) {
                    gameOverTimer += dt;
                    if (gameOverTimer >= 1.2) showGameOverUI = true;
                }
            }

            if (gameOver) return;

            const pixelsPerSecond = gameSpeed * 60;
            kangaroo.update(dt);
            updateObstacles(dt, pixelsPerSecond);
            updateCoins(dt, pixelsPerSecond);

            gameSpeed = Math.min(MAX_SPEED, gameSpeed + SPEED_INCREMENT);
            score += 6 * dt;

            if (checkCollisions()) {
                gameOver = true;
                playSound('collision');
                playSound('gameOver');
                playMusic('musicMenu');  // Switch to menu music
                // Stop all Lottie animations
                Object.values(lottieAnimations).forEach(anim => anim.pause());
                kangaroo.die();
                if (score > highScore) {
                    highScore = Math.floor(score);
                    localStorage.setItem('kangaroo_lottie_high', highScore);
                }
                localStorage.setItem('kangaroo_lottie_coins', totalCoins);
            }
        }

        function draw() {
            ctx.fillStyle = '#4A90D9';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            drawBackground();
            drawGround();

            // Jump debug mode - show 4 kangaroos with different jump configs
            if (JUMP_DEBUG) {
                drawDebugKangaroos();
                // Title
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 24px Poppins';
                ctx.textAlign = 'center';
                ctx.fillText('JUMP FRAME DEBUG - Pick the best one!', CANVAS_WIDTH / 2, 50);
                return;
            }

            if (!gameStarted) {
                kangaroo.draw();
                drawStartScreen();
            } else if (gameOver) {
                drawObstacles();
                drawCoins();
                drawParticles();
                kangaroo.draw();
                drawUI();
                if (showGameOverUI) drawGameOver();
            } else {
                drawObstacles();
                drawCoins();
                drawParticles();
                kangaroo.draw();
                drawUI();
            }
        }

        function gameLoop(currentTime) {
            deltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;
            deltaTime = Math.min(deltaTime, 0.1);

            update(deltaTime);
            draw();
            requestAnimationFrame(gameLoop);
        }

        // === INPUT ===
        function handleInput() {
            if (!gameStarted) {
                playSound('buttonClick');
                gameStarted = true;
                playMusic('musicGame');  // Start game music
                reset();
            } else if (gameOver) {
                if (showGameOverUI) {
                    playSound('buttonClick');
                    playMusic('musicGame');  // Restart game music
                    reset();
                }
            } else {
                kangaroo.jump();
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault();
                handleInput();
            }
        });

        canvas.addEventListener('click', handleInput);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleInput();
        });

        // === START ===
        async function init() {
            loadingEl.textContent = 'Loading images...';

            // Load regular assets
            await new Promise(resolve => loadAssets(resolve));

            // Load Lottie animations
            loadingEl.textContent = 'Loading Lottie animations...';
            await loadAllLotties();

            loadingEl.style.display = 'none';
            playMusic('musicMenu');  // Start menu music
            gameLoop(performance.now());
        }

        init();
    </script>
</body>
</html>
