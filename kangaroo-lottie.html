<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kangaroo Hop - Lottie Edition</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            font-family: 'Poppins', sans-serif;
        }
        #gameContainer {
            position: relative;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5), 0 0 40px rgba(79, 172, 254, 0.15);
        }
        canvas {
            display: block;
            border-radius: 16px;
            cursor: pointer;
            transform: translateZ(0);
            will-change: transform;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            font-weight: 600;
        }
        /* Container for Lottie rendering - hidden but must render */
        #lottieContainer {
            position: fixed;
            bottom: 0;
            right: 0;
            opacity: 0.01;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="game" width="800" height="600"></canvas>
        <div id="loading">Loading...</div>
    </div>
    <div id="lottieContainer"></div>

    <script type="module">
        // Import DotLottie from jsdelivr (better CORS support)
        import { DotLottie } from 'https://cdn.jsdelivr.net/npm/@lottiefiles/dotlottie-web@0.37.0/+esm';

        // ============================================
        // KANGAROO HOP - Lottie Edition
        // Raw Canvas + Lottie Animations
        // ============================================

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d', {
            alpha: false,
            desynchronized: true
        });
        const loadingEl = document.getElementById('loading');
        const lottieContainer = document.getElementById('lottieContainer');

        // === LOTTIE SYSTEM ===
        const lottieAnimations = {};
        const lottieCanvases = {};

        // Define your Lottie obstacles here - easy to add more!
        const LOTTIE_OBSTACLES = {
            camel: {
                src: 'assets/lottie/camel.lottie',
                width: 200,
                height: 180,
                hitboxWidth: 140,
                hitboxHeight: 80,
                hitboxOffsetY: 40,
                groundOffset: 0,
                flipX: true
            },
            crocodile: {
                src: 'assets/lottie/crocodile_scooter.lottie',
                width: 280,
                height: 230,
                hitboxWidth: 180,
                hitboxHeight: 120,
                hitboxOffsetY: 30,
                groundOffset: -40,  // Push down to align with ground
                flipX: false,  // Faces left naturally
                speedMultiplier: 1.5,  // Moves 50% faster than normal obstacles
                animationSpeed: 2.0    // Animation plays 2x faster
            }
        };

        async function loadLottieAnimation(name, config) {
            return new Promise((resolve, reject) => {
                // Create a DOM canvas in the hidden container - DotLottie needs visible DOM canvas
                const lottieCanvas = document.createElement('canvas');
                lottieCanvas.id = `lottie-${name}`;
                lottieCanvas.width = config.width;
                lottieCanvas.height = config.height;
                lottieContainer.appendChild(lottieCanvas);  // Use the hidden container

                try {
                    const dotLottie = new DotLottie({
                        canvas: lottieCanvas,
                        src: config.src,
                        loop: true,
                        autoplay: true,
                        speed: config.animationSpeed || 1.0  // Animation playback speed
                    });

                    dotLottie.addEventListener('load', () => {
                        lottieAnimations[name] = dotLottie;
                        lottieCanvases[name] = lottieCanvas;
                        resolve(dotLottie);
                    });

                    dotLottie.addEventListener('loadError', (error) => {
                        console.error(`âœ— Failed to load Lottie: ${name}`, error);
                        reject(error);
                    });

                    // Timeout fallback
                    setTimeout(() => {
                        if (!lottieAnimations[name] && dotLottie.isLoaded) {
                            lottieAnimations[name] = dotLottie;
                            lottieCanvases[name] = lottieCanvas;
                            resolve(dotLottie);
                        }
                    }, 3000);
                } catch (err) {
                    console.error(`Error creating DotLottie for ${name}:`, err);
                    reject(err);
                }
            });
        }

        async function loadAllLotties() {
            const promises = Object.entries(LOTTIE_OBSTACLES).map(([name, config]) =>
                loadLottieAnimation(name, config).catch(() => null)
            );
            await Promise.all(promises);
        }

        // === AUDIO ===
        const sounds = {
            jump: new Audio('assets/audio/sfx/jump.mp3'),
            doubleJump: new Audio('assets/audio/sfx/double_jump.mp3'),
            coin: new Audio('assets/audio/sfx/coin_collect.mp3'),
            collision: new Audio('assets/audio/sfx/collision.mp3'),
            gameOver: new Audio('assets/audio/sfx/game_over.mp3')
        };

        sounds.jump.volume = 0.5;
        sounds.doubleJump.volume = 0.5;
        sounds.coin.volume = 0.7;
        sounds.collision.volume = 0.6;
        sounds.gameOver.volume = 0.8;

        function playSound(name) {
            if (!soundEnabled) return;
            const sound = sounds[name];
            if (sound) {
                sound.currentTime = 0;
                sound.play().catch(() => {});
            }
        }

        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        // === CONSTANTS ===
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const GROUND_Y = 500;
        const GRAVITY = 0.8;
        const JUMP_FORCE = -20;
        const INITIAL_SPEED = 6;
        const MAX_SPEED = 14;
        const SPEED_INCREMENT = 0.002;
        const DEBUG = false;  // Set true to see hitboxes

        // === PARTICLES ===
        let particles = [];

        function spawnDustParticles(x, y) {
            const count = 8 + Math.floor(Math.random() * 5);
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 40,
                    y: y,
                    vx: (Math.random() - 0.5) * 150,
                    vy: -Math.random() * 80 - 20,
                    size: 4 + Math.random() * 8,
                    life: 0.4 + Math.random() * 0.3,
                    maxLife: 0.4 + Math.random() * 0.3,
                    color: Math.random() > 0.5 ? '#C4A574' : '#A68B5B',
                    type: 'dust'
                });
            }
        }

        function spawnCoinSparkles(x, y) {
            const count = 12 + Math.floor(Math.random() * 6);
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
                const speed = 100 + Math.random() * 150;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 3 + Math.random() * 5,
                    life: 0.3 + Math.random() * 0.3,
                    maxLife: 0.3 + Math.random() * 0.3,
                    color: Math.random() > 0.5 ? '#FFD700' : '#FFF176',
                    type: 'sparkle'
                });
            }
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;

                if (p.type === 'dust') {
                    p.vy += 200 * dt;
                } else if (p.type === 'sparkle') {
                    p.vx *= 0.95;
                    p.vy *= 0.95;
                }

                p.life -= dt;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                const alpha = p.life / p.maxLife;

                if (p.type === 'sparkle') {
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(Math.round(p.x), Math.round(p.y), p.size * alpha * 1.5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(Math.round(p.x), Math.round(p.y), p.size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.globalAlpha = alpha * 0.7;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(Math.round(p.x), Math.round(p.y), p.size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            ctx.globalAlpha = 1;
        }

        // === ASSETS ===
        const assets = {};

        // Kangaroo animation frames (from Phaser version's character system)
        const KANGAROO_ANIMATIONS = {
            moving: { prefix: 'red_kangaroo_no_joey_moving', frameCount: 16, frameRate: 20 },
            jump: { prefix: 'red_kangaroo_no_joey_jump_from_idle', frameCount: 10, frameRate: 15 },
            die: { prefix: 'red_kangaroo_no_joey_die', frameCount: 5, frameRate: 10 },
            idle: { prefix: 'red_kangaroo_no_joey_idle', frameCount: 20, frameRate: 12 }
        };

        // Store animation frames
        const kangarooFrames = {
            moving: [],
            jump: [],
            die: [],
            idle: []
        };

        const assetList = [
            { name: 'ground', src: 'assets/images/parallax/_01_ground.png' },
            { name: 'clouds', src: 'assets/images/parallax/_08_clouds.png' },
            { name: 'hills', src: 'assets/images/parallax/_06_hill2.png' },
            { name: 'coin', src: 'assets/images/coin/coin-64x64.png' }
        ];

        function loadAssets(callback) {
            let loaded = 0;
            let total = assetList.length;

            // Calculate total frames to load
            Object.values(KANGAROO_ANIMATIONS).forEach(anim => {
                total += anim.frameCount;
            });

            if (total === 0) {
                callback();
                return;
            }

            const checkComplete = () => {
                loadingEl.textContent = `Loading... ${Math.floor(loaded / total * 100)}%`;
                if (loaded === total) callback();
            };

            // Load regular assets
            assetList.forEach(asset => {
                const img = new Image();
                img.onload = () => {
                    assets[asset.name] = img;
                    loaded++;
                    checkComplete();
                };
                img.onerror = () => {
                    console.error(`Failed to load: ${asset.name}`);
                    loaded++;
                    checkComplete();
                };
                img.src = asset.src;
            });

            // Load kangaroo animation frames
            Object.entries(KANGAROO_ANIMATIONS).forEach(([animName, config]) => {
                for (let i = 0; i < config.frameCount; i++) {
                    const frameNum = String(i).padStart(3, '0');
                    const img = new Image();
                    img.onload = () => {
                        kangarooFrames[animName][i] = img;
                        loaded++;
                        checkComplete();
                    };
                    img.onerror = () => {
                        console.error(`Failed to load kangaroo frame: ${animName}_${frameNum}`);
                        loaded++;
                        checkComplete();
                    };
                    img.src = `assets/characters/kangaroo/brown/${config.prefix}_${frameNum}.png`;
                }
            });
        }

        // === GAME STATE ===
        let gameSpeed = INITIAL_SPEED;
        let score = 0;
        let highScore = parseInt(localStorage.getItem('kangaroo_lottie_high')) || 0;
        let coinsCollected = 0;
        let totalCoins = parseInt(localStorage.getItem('kangaroo_lottie_coins')) || 0;
        let gameOver = false;
        let showGameOverUI = false;
        let gameOverTimer = 0;
        let gameStarted = false;
        let soundEnabled = true;
        let groundOffset = 0;
        let cloudsOffset = 0;
        let hillsOffset = 0;
        let deltaTime = 0;
        let lastFrameTime = performance.now();

        // Menu animation
        let menuKangarooY = 0;
        let menuKangarooVel = 0;
        let menuBounceTimer = 0;

        // === KANGAROO ===
        const DOUBLE_JUMP_FORCE = -17;

        const kangaroo = {
            x: 100,
            y: GROUND_Y,
            width: 154,           // Match Phaser version display size
            height: 178,
            velocityY: 0,
            onGround: true,
            wasOnGround: true,
            canDoubleJump: false,

            // Animation state
            currentAnim: 'moving',
            frame: 0,
            frameTimer: 0,

            // Squash & stretch
            scaleX: 1,
            scaleY: 1,
            squashTime: 0,

            // Death state
            isDead: false,
            deathFrame: 0,

            update(dt) {
                // Update animation frame
                this.frameTimer += dt;
                const anim = KANGAROO_ANIMATIONS[this.currentAnim];
                const frameDelay = 1 / anim.frameRate;

                if (this.frameTimer >= frameDelay) {
                    this.frameTimer = 0;

                    if (this.isDead) {
                        // Death animation plays once
                        if (this.deathFrame < KANGAROO_ANIMATIONS.die.frameCount - 1) {
                            this.deathFrame++;
                        }
                    } else {
                        // Loop other animations
                        const maxFrames = kangarooFrames[this.currentAnim].length;
                        this.frame = (this.frame + 1) % maxFrames;
                    }
                }

                if (this.isDead) return;

                this.wasOnGround = this.onGround;
                const gravityPerSecond = GRAVITY * 60;
                this.velocityY += gravityPerSecond * dt;
                this.y += this.velocityY * dt * 60;

                if (this.y >= GROUND_Y) {
                    this.y = GROUND_Y;
                    this.velocityY = 0;
                    this.onGround = true;
                    this.canDoubleJump = false;

                    // Switch to moving animation when landing
                    if (!this.wasOnGround) {
                        this.currentAnim = 'moving';
                        this.frame = 0;
                        this.squashTime = 0.15;
                        this.scaleX = 1.3;
                        this.scaleY = 0.7;
                        // Spawn dust particles!
                        spawnDustParticles(this.x, GROUND_Y);
                    }
                } else {
                    // In air - use jump animation
                    if (this.currentAnim !== 'jump') {
                        this.currentAnim = 'jump';
                        this.frame = 0;
                    }
                }

                // Animate squash back to normal
                if (this.squashTime > 0) {
                    this.squashTime -= dt;
                    this.scaleX += (1 - this.scaleX) * 10 * dt;
                    this.scaleY += (1 - this.scaleY) * 10 * dt;
                } else {
                    this.scaleX = 1;
                    this.scaleY = 1;
                }
            },

            die() {
                this.isDead = true;
                this.currentAnim = 'die';
                this.deathFrame = 0;
                this.frame = 0;
            },

            jump() {
                if (this.isDead) return;
                if (this.onGround) {
                    this.velocityY = JUMP_FORCE;
                    this.onGround = false;
                    this.canDoubleJump = true;
                    this.currentAnim = 'jump';
                    this.frame = 0;
                    playSound('jump');
                    this.scaleX = 0.8;
                    this.scaleY = 1.2;
                    this.squashTime = 0.1;
                } else if (this.canDoubleJump) {
                    this.velocityY = DOUBLE_JUMP_FORCE;
                    this.canDoubleJump = false;
                    this.frame = 0;
                    playSound('doubleJump');
                    this.scaleX = 0.8;
                    this.scaleY = 1.2;
                    this.squashTime = 0.1;
                }
            },

            draw() {
                const scaledWidth = this.width * this.scaleX;
                const scaledHeight = this.height * this.scaleY;
                const drawX = Math.round(this.x);
                const drawY = Math.round(this.y);

                ctx.save();

                // Get the right frame
                let frameImg;
                if (this.isDead) {
                    frameImg = kangarooFrames.die[this.deathFrame];
                } else {
                    frameImg = kangarooFrames[this.currentAnim][this.frame];
                }

                if (frameImg) {
                    // Flip horizontally - kangaroo sprites face left, we need right
                    // Offset to align feet with ground (sprites have padding)
                    const groundAdjust = 30;
                    ctx.translate(drawX, drawY + groundAdjust);
                    ctx.scale(-1, 1);  // Flip horizontally
                    ctx.drawImage(
                        frameImg,
                        -scaledWidth / 2,
                        -scaledHeight,
                        scaledWidth,
                        scaledHeight
                    );
                }

                ctx.restore();

                if (DEBUG) {
                    const bounds = this.getBounds();
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);
                }
            },

            getBounds() {
                // Hitbox aligned with visual sprite (+30 ground adjust, +20 forward)
                return {
                    x: this.x - 36 + 20,  // Moved 20px forward
                    y: this.y - 120 + 30,
                    width: 72,
                    height: 75
                };
            }
        };

        // === OBSTACLES (Now with Lottie support!) ===
        let obstacles = [];
        let lastObstacleTime = 0;
        let obstacleInterval = 1500;

        function spawnObstacle() {
            // For now, spawn Lottie camel as the main obstacle
            const lottieNames = Object.keys(lottieAnimations);

            if (lottieNames.length > 0) {
                // Pick a random Lottie obstacle
                const name = lottieNames[Math.floor(Math.random() * lottieNames.length)];
                const config = LOTTIE_OBSTACLES[name];

                obstacles.push({
                    x: CANVAS_WIDTH + 50,
                    y: GROUND_Y - config.groundOffset,
                    width: config.width,
                    height: config.height,
                    hitboxWidth: config.hitboxWidth,
                    hitboxHeight: config.hitboxHeight,
                    hitboxOffsetY: config.hitboxOffsetY || 0,
                    speedMultiplier: config.speedMultiplier || 1.0,
                    lottie: name,  // Reference to Lottie animation
                    isLottie: true
                });
            }
        }

        function updateObstacles(dt, pixelsPerSecond) {
            const now = Date.now();

            if (now - lastObstacleTime > obstacleInterval) {
                spawnObstacle();
                lastObstacleTime = now;
                obstacleInterval = 1200 + Math.random() * 800 - (score * 0.5);
                obstacleInterval = Math.max(600, obstacleInterval);
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                const speedMult = obs.speedMultiplier || 1.0;
                obs.x -= pixelsPerSecond * speedMult * dt;

                if (obs.x < -150) {
                    obstacles.splice(i, 1);
                    score += 10;
                }
            }
        }

        function drawObstacles() {
            obstacles.forEach(obs => {
                if (obs.isLottie && lottieCanvases[obs.lottie]) {
                    const offCanvas = lottieCanvases[obs.lottie];
                    const config = LOTTIE_OBSTACLES[obs.lottie];

                    ctx.save();

                    // Adjust to align with ground (Lottie may have padding)
                    const groundAdjust = 40;

                    // Flip horizontally if needed (to face left)
                    if (config && config.flipX) {
                        ctx.translate(obs.x, 0);
                        ctx.scale(-1, 1);
                        ctx.drawImage(
                            offCanvas,
                            0, 0, offCanvas.width, offCanvas.height,
                            -obs.width / 2,
                            Math.round(obs.y - obs.height + groundAdjust),
                            obs.width,
                            obs.height
                        );
                    } else {
                        ctx.drawImage(
                            offCanvas,
                            0, 0, offCanvas.width, offCanvas.height,
                            Math.round(obs.x - obs.width / 2),
                            Math.round(obs.y - obs.height + groundAdjust),
                            obs.width,
                            obs.height
                        );
                    }

                    ctx.restore();
                }

                // Debug: draw hitbox (adjusted for ground offset)
                if (DEBUG) {
                    const hbWidth = obs.hitboxWidth || obs.width - 20;
                    const hbHeight = obs.hitboxHeight || obs.height - 20;
                    const hbOffsetY = obs.hitboxOffsetY || 0;
                    const groundAdjust = 40;  // Match visual offset
                    ctx.strokeStyle = '#FF0000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(
                        Math.round(obs.x - hbWidth / 2),
                        Math.round(obs.y - hbHeight - hbOffsetY + groundAdjust),
                        hbWidth,
                        hbHeight
                    );
                }
            });
        }

        // === COINS ===
        let coins = [];

        function spawnCoin(x) {
            coins.push({
                x: x || CANVAS_WIDTH + Math.random() * 200,
                y: GROUND_Y - 50 - Math.random() * 80,
                size: 40,
                frame: 0,
                frameTimer: 0,
                collected: false
            });
        }

        function updateCoins(dt, pixelsPerSecond) {
            if (Math.random() < 0.6 * dt) spawnCoin();

            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                coin.x -= pixelsPerSecond * dt;
                coin.frameTimer += dt;
                if (coin.frameTimer >= 0.04) {
                    coin.frameTimer = 0;
                    coin.frame = (coin.frame + 1) % 25;
                }

                if (!coin.collected) {
                    const k = kangaroo.getBounds();
                    if (k.x < coin.x + coin.size && k.x + k.width > coin.x - coin.size &&
                        k.y < coin.y + coin.size && k.y + k.height > coin.y - coin.size) {
                        coin.collected = true;
                        coinsCollected++;
                        totalCoins++;
                        score += 5;
                        playSound('coin');
                        spawnCoinSparkles(coin.x, coin.y);
                    }
                }

                if (coin.x < -50 || coin.collected) {
                    coins.splice(i, 1);
                }
            }
        }

        function drawCoins() {
            coins.forEach(coin => {
                if (assets.coin) {
                    ctx.drawImage(
                        assets.coin,
                        coin.frame * 64, 0, 64, 64,
                        Math.round(coin.x - coin.size / 2),
                        Math.round(coin.y - coin.size / 2),
                        coin.size, coin.size
                    );
                } else {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(coin.x, coin.y, coin.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        // === COLLISION ===
        function checkCollisions() {
            const k = kangaroo.getBounds();

            for (const obs of obstacles) {
                const hbWidth = obs.hitboxWidth || obs.width - 20;
                const hbHeight = obs.hitboxHeight || obs.height - 20;
                const hbOffsetY = obs.hitboxOffsetY || 0;
                const groundAdjust = 40;  // Match visual offset
                const o = {
                    x: obs.x - hbWidth / 2,
                    y: obs.y - hbHeight - hbOffsetY + groundAdjust,
                    width: hbWidth,
                    height: hbHeight
                };

                if (k.x < o.x + o.width && k.x + k.width > o.x &&
                    k.y < o.y + o.height && k.y + k.height > o.y) {
                    return true;
                }
            }
            return false;
        }

        // === BACKGROUND ===
        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
            gradient.addColorStop(0, '#4A90D9');
            gradient.addColorStop(0.5, '#87CEEB');
            gradient.addColorStop(1, '#B0E0E6');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, GROUND_Y);

            if (assets.clouds) {
                const cloudWidth = assets.clouds.width;
                // Only scroll if not game over
                if (!gameOver) {
                    cloudsOffset = (cloudsOffset + gameSpeed * 60 * 0.1 * deltaTime) % cloudWidth;
                }
                ctx.globalAlpha = 0.6;
                for (let x = -cloudsOffset; x < CANVAS_WIDTH + cloudWidth; x += cloudWidth) {
                    ctx.drawImage(assets.clouds, Math.round(x), 40, cloudWidth * 0.8, 80);
                }
                ctx.globalAlpha = 1;
            }

            if (assets.hills) {
                const hillWidth = assets.hills.width * 0.4;
                // Only scroll if not game over
                if (!gameOver) {
                    hillsOffset = (hillsOffset + gameSpeed * 60 * 0.15 * deltaTime) % hillWidth;
                }
                ctx.globalAlpha = 0.5;
                for (let x = -hillsOffset; x < CANVAS_WIDTH + hillWidth; x += hillWidth) {
                    ctx.drawImage(assets.hills, Math.round(x), GROUND_Y - 120, hillWidth, 130);
                }
                ctx.globalAlpha = 1;
            }
        }

        function drawGround() {
            if (assets.ground) {
                const groundWidth = assets.ground.width;
                // Only scroll if not game over
                if (!gameOver) {
                    groundOffset = (groundOffset + gameSpeed * 60 * deltaTime) % groundWidth;
                }
                for (let x = -groundOffset; x < CANVAS_WIDTH + groundWidth; x += groundWidth) {
                    ctx.drawImage(assets.ground, Math.round(x), GROUND_Y, groundWidth, CANVAS_HEIGHT - GROUND_Y + 20);
                }
            } else {
                ctx.fillStyle = '#C4A574';
                ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, CANVAS_HEIGHT - GROUND_Y);
            }
            ctx.fillStyle = '#8B7355';
            ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, 4);

            // Debug: show ground collision line
            if (DEBUG) {
                ctx.strokeStyle = '#00FF00';
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.moveTo(0, GROUND_Y);
                ctx.lineTo(CANVAS_WIDTH, GROUND_Y);
                ctx.stroke();
                ctx.setLineDash([]);

                // Label
                ctx.fillStyle = '#00FF00';
                ctx.font = '12px monospace';
                ctx.fillText(`GROUND_Y = ${GROUND_Y}`, 10, GROUND_Y - 5);
            }
        }

        // === UI ===
        function drawUI() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            roundRect(ctx, CANVAS_WIDTH - 160, 10, 150, 70, 12);
            ctx.fill();

            ctx.fillStyle = '#FFF';
            ctx.font = '600 28px Poppins';
            ctx.textAlign = 'right';
            ctx.fillText(Math.floor(score), CANVAS_WIDTH - 25, 45);
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.font = '400 14px Poppins';
            ctx.fillText(`BEST: ${Math.floor(highScore)}`, CANVAS_WIDTH - 25, 68);

            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            roundRect(ctx, 10, 10, 130, 70, 12);
            ctx.fill();

            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(40, 35, 15, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#FFF';
            ctx.font = '700 22px Poppins';
            ctx.textAlign = 'left';
            ctx.fillText(totalCoins, 65, 42);
            ctx.fillStyle = '#4ADE80';
            ctx.font = '600 14px Poppins';
            ctx.fillText(`+${coinsCollected}`, 65, 62);

            // Lottie indicator
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            roundRect(ctx, 10, 90, 180, 30, 8);
            ctx.fill();
            ctx.fillStyle = '#4ADE80';
            ctx.font = '600 12px Poppins';
            ctx.fillText(`Lottie Obstacles: ${Object.keys(lottieAnimations).length}`, 20, 110);
        }

        function updateMenu(dt) {
            menuBounceTimer += dt;
            if (menuBounceTimer > 1.2) {
                menuBounceTimer = 0;
                menuKangarooVel = -8;
            }
            menuKangarooVel += 25 * dt;
            menuKangarooY += menuKangarooVel;
            if (menuKangarooY > 0) {
                menuKangarooY = 0;
                menuKangarooVel = 0;
            }
        }

        function drawStartScreen() {
            const overlay = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
            overlay.addColorStop(0, 'rgba(15, 23, 42, 0.85)');
            overlay.addColorStop(1, 'rgba(15, 23, 42, 0.6)');
            ctx.fillStyle = overlay;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.textAlign = 'center';
            const centerX = CANVAS_WIDTH / 2;

            // Draw kangaroo on menu using idle animation
            const idleFrames = kangarooFrames.idle;
            if (idleFrames && idleFrames.length > 0) {
                const frame = Math.floor(menuBounceTimer * 12) % idleFrames.length;
                const frameImg = idleFrames[frame];
                const kY = 160 + menuKangarooY;
                let scaleX = 1, scaleY = 1;
                if (menuKangarooVel < -2) { scaleX = 0.85; scaleY = 1.15; }
                else if (menuKangarooY === 0 && menuKangarooVel === 0) { scaleX = 1.1; scaleY = 0.9; }
                if (frameImg) {
                    // Flip to face right
                    ctx.save();
                    ctx.translate(centerX, kY);
                    ctx.scale(-1, 1);
                    ctx.drawImage(frameImg,
                        -60 * scaleX, -130 * scaleY, 120 * scaleX, 130 * scaleY);
                    ctx.restore();
                }
            }

            ctx.font = '800 48px Poppins';
            ctx.fillStyle = '#FFF';
            ctx.fillText('KANGAROO', centerX, 220);
            ctx.fillStyle = '#4ADE80';
            ctx.fillText('HOP', centerX, 275);

            // Lottie badge
            ctx.fillStyle = '#FF69B4';
            ctx.font = '600 14px Poppins';
            ctx.fillText('LOTTIE EDITION', centerX, 300);

            const btnGrad = ctx.createLinearGradient(centerX - 100, 320, centerX - 100, 375);
            btnGrad.addColorStop(0, '#4ADE80');
            btnGrad.addColorStop(1, '#22C55E');
            ctx.fillStyle = btnGrad;
            roundRect(ctx, centerX - 100, 320, 200, 55, 27);
            ctx.fill();

            ctx.fillStyle = '#FFF';
            ctx.font = '700 20px Poppins';
            ctx.fillText('TAP TO PLAY', centerX, 355);

            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.font = '400 13px Poppins';
            ctx.fillText('SPACE or Click to jump', centerX, 560);
        }

        function drawGameOver() {
            const overlay = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
            overlay.addColorStop(0, 'rgba(15, 23, 42, 0.95)');
            overlay.addColorStop(1, 'rgba(15, 23, 42, 0.85)');
            ctx.fillStyle = overlay;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.textAlign = 'center';
            ctx.font = '800 42px Poppins';
            ctx.fillStyle = '#F87171';
            ctx.fillText('GAME OVER', CANVAS_WIDTH / 2, 140);

            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            roundRect(ctx, CANVAS_WIDTH / 2 - 120, 170, 240, 140, 16);
            ctx.fill();

            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = '400 14px Poppins';
            ctx.fillText('SCORE', CANVAS_WIDTH / 2, 200);
            ctx.fillStyle = '#FFF';
            ctx.font = '800 48px Poppins';
            ctx.fillText(Math.floor(score), CANVAS_WIDTH / 2, 255);

            if (score >= highScore && score > 0) {
                ctx.fillStyle = '#FBBF24';
                ctx.font = '700 16px Poppins';
                ctx.fillText('NEW BEST!', CANVAS_WIDTH / 2, 290);
            }

            ctx.fillStyle = '#4ADE80';
            ctx.font = '600 18px Poppins';
            ctx.fillText(`+${coinsCollected} coins`, CANVAS_WIDTH / 2, 360);

            const btnGrad = ctx.createLinearGradient(CANVAS_WIDTH / 2 - 90, 400, CANVAS_WIDTH / 2 - 90, 450);
            btnGrad.addColorStop(0, '#4ADE80');
            btnGrad.addColorStop(1, '#22C55E');
            ctx.fillStyle = btnGrad;
            roundRect(ctx, CANVAS_WIDTH / 2 - 90, 400, 180, 50, 25);
            ctx.fill();

            ctx.fillStyle = '#FFF';
            ctx.font = '700 18px Poppins';
            ctx.fillText('PLAY AGAIN', CANVAS_WIDTH / 2, 432);
        }

        // === GAME LOOP ===
        function reset() {
            // Reset kangaroo fully
            kangaroo.x = 100;
            kangaroo.y = GROUND_Y;
            kangaroo.velocityY = 0;
            kangaroo.onGround = true;
            kangaroo.wasOnGround = true;
            kangaroo.canDoubleJump = false;
            kangaroo.currentAnim = 'moving';
            kangaroo.frame = 0;
            kangaroo.frameTimer = 0;
            kangaroo.scaleX = 1;
            kangaroo.scaleY = 1;
            kangaroo.squashTime = 0;
            kangaroo.isDead = false;
            kangaroo.deathFrame = 0;

            // Reset game state
            obstacles = [];
            coins = [];
            particles = [];
            gameSpeed = INITIAL_SPEED;
            score = 0;
            coinsCollected = 0;
            gameOver = false;
            showGameOverUI = false;
            gameOverTimer = 0;
            lastObstacleTime = Date.now();
        }

        function update(dt) {
            // Always update particles
            updateParticles(dt);

            if (!gameStarted) {
                updateMenu(dt);
                return;
            }

            if (gameOver && kangaroo.isDead) {
                kangaroo.update(dt);
                if (!showGameOverUI) {
                    gameOverTimer += dt;
                    if (gameOverTimer >= 1.2) showGameOverUI = true;
                }
            }

            if (gameOver) return;

            const pixelsPerSecond = gameSpeed * 60;
            kangaroo.update(dt);
            updateObstacles(dt, pixelsPerSecond);
            updateCoins(dt, pixelsPerSecond);

            gameSpeed = Math.min(MAX_SPEED, gameSpeed + SPEED_INCREMENT);
            score += 6 * dt;

            if (checkCollisions()) {
                gameOver = true;
                playSound('collision');
                playSound('gameOver');
                kangaroo.die();
                if (score > highScore) {
                    highScore = Math.floor(score);
                    localStorage.setItem('kangaroo_lottie_high', highScore);
                }
                localStorage.setItem('kangaroo_lottie_coins', totalCoins);
            }
        }

        function draw() {
            ctx.fillStyle = '#4A90D9';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            drawBackground();
            drawGround();

            if (!gameStarted) {
                kangaroo.draw();
                drawStartScreen();
            } else if (gameOver) {
                drawObstacles();
                drawCoins();
                drawParticles();
                kangaroo.draw();
                drawUI();
                if (showGameOverUI) drawGameOver();
            } else {
                drawObstacles();
                drawCoins();
                drawParticles();
                kangaroo.draw();
                drawUI();
            }
        }

        function gameLoop(currentTime) {
            deltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;
            deltaTime = Math.min(deltaTime, 0.1);

            update(deltaTime);
            draw();
            requestAnimationFrame(gameLoop);
        }

        // === INPUT ===
        function handleInput() {
            if (!gameStarted) {
                gameStarted = true;
                reset();
            } else if (gameOver) {
                if (showGameOverUI) reset();
            } else {
                kangaroo.jump();
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault();
                handleInput();
            }
        });

        canvas.addEventListener('click', handleInput);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleInput();
        });

        // === START ===
        async function init() {
            loadingEl.textContent = 'Loading images...';

            // Load regular assets
            await new Promise(resolve => loadAssets(resolve));

            // Load Lottie animations
            loadingEl.textContent = 'Loading Lottie animations...';
            await loadAllLotties();

            loadingEl.style.display = 'none';
            gameLoop(performance.now());
        }

        init();
    </script>
</body>
</html>
